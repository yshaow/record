1.vuejs简洁
	vuejs是轻量级的MVVM框架，它同时具备了ng与react的优点，它吸收了react的组件化同时也具备ng中灵活的指令。
	双向绑定
2.vue.js的一个组件
		-- html  <template></template>
	*.vue	-- js	 <script></script>
		-- css	 <style></style>
3.vue的安装
	》全局安装vue-cli
		npm install -g vue-cli
	》创建一个基于webpack模板的新项目
		vue init webpack my-project(项目名称)
	》安装依赖
		cd my-project
		npm install
		npm run dev
4.vue组件的重要选项
	new Vue({
		data:{//vue的所有数据都是放置在该属性中，这里面的数据可以进行"双向绑定"  <p>{{a}}</p>
			a:1
		},
		methods:{//放置方法位置
			doSomething：function(){
				this.a++;
			}
		},
		watch:{//监听
			'a':function(val,oldVal){
				console.log(val,oldVal);
			}
		}
	});
	》模板指令 html与vue对象的粘合剂
		数据渲染 v-text  v-html {{}}
			<P>{{a}}</p>
			<p v-text='a'></p>
			<p v-html='a'></p>
		控制模块隐藏:v-if  v-show
			它们的区别：
				v-if是直接不渲染DOM元素
				v-show是通过display来实现的
				<p v-if='isShow'></p>
				<p v-show='isShow'></p>
				new Vue({
					data:{
						isShow:true
					}
				});
		渲染循环列表 v-for
			data:{
				items:[
					{
						label:'apple'
					},
					{
						label:'banana'
					}
				]
			}
			<ul>
				<li v-for='item in items'>
					<p v-text='item.label'></p>
				</li>
			</ul>
		事件绑定：v-on  可简写为：@
			methods:{
				doThis:function(someThing){
					...
				}
			}
			<button v-on:click='doThis'></button>
			<button @click='doThis'></button>
		属性绑定:v-bind
			<img v-bind:src='imageSrc'>
			由于v-bind:class是比较常用的，则可简写为:class
			<div :class='{red:isRed}'></div>//isRed表示是否有的判断
			<div :class='[classA,classB]'></div>//表示字符串class
			<div :class='classA,{classB:isB,classC:isC}'></div>
总结：
	》new一个vue对象的时候你可以设置它的属性，其中最重要的包括三个分别是data、methods、watch。其中data代表vue对象的数据，methods代表vue对象
	  的方法，watch设置了对象监听的方法
	》vue对象里的设置通过html指令进行关联
5.vue自动项目结构分析
	index.html--所有文件的入口  <app></app>--组件引用  需要注册了才能在html页面像标签一样的使用
/*********************Vue文档分析***********************/
1.安装
	》兼容性
		Vue不支持IE8及其以下版本，因为vue.js使用了IE8不能模拟的ES5的特性，vue支持所有兼容ES5的浏览器
	》独立版本
		直接下载并用<script>标签引入，Vue会被注册为一个全局变量
			》推荐 https://unpkg.com/vue@2.1.10/dist/vue.js 会保持和npm发布的最新的版本一致
		NPM--在用vue构建大型应用时推荐使用npm安装，npm能很好的和诸如webpack或Browserify模块打包器配合使用
		     Vue也提供配套工具来开发单文件组件
		     npm install vue
			独立构建 VS 运行时构建
				有两种构建方式，独立构建和运行时构建。它们的区别在于前者包含模板编译器，而后者不包含。
				模板编译器用于编译vue模板字符串成纯js渲染函数。如果你想用template选项，你需要编译。
				模板编译器的职责是将模板字符串编译为纯的js的渲染函数，如果你想要在组件中使用template选项，你就需要编译器
				》独立构建包含模板编译器并支持template选项，它依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染
				》运行时构建不包含模板编译器，因此它不支持template选项，只能用于render选项，但即使使用运行时构建，在单文件
				  组件中也依然可以写模板，因为单文件组件的模板会在构建预编译为render函数。运行是构建比独立构建要轻量30%。
			默认NPM包导出的是运行时构建。为了使用独立构建，在webpack配置中添加下面的别名：
				resolve: {
				  alias: {
				    'vue$': 'vue/dist/vue.common.js'
				  }
				}
			对于Browserify，可以添加一个别名到package.json中
				"browser": {
				  "vue": "vue/dist/vue.common"
				},
		CSP环境
			有些环境如Google Chrome Apps，强制应用内容安全策略CSP，不能使用new Function()对表达式求值。这时可以用CSP兼容版本。独立的构建取决于
			该功能编译模板，所以无法使用这些环境。
			另一方面，运行时构建的是完全兼容CSP的，当通过webpack+vue-loader或Browserify+vueify构建时，在CSP环境中模板将被完美预编译到render函数中
	》命令行工具
		vue提供了一个官方命令行工具，可以用于快速搭建**大型单页面应用**。该工具提供开箱即用的构建工具配置，带来了现代化的前端开发流程。只需几分钟即可
		创建并启动一个带热重载，保持静态检查以及可用于生产环境的构建配置的项目
			全局安装 vue-cli
				npm install --global vue-cli
			创建一个基于webpack模板的项目
				vue init webpack my-project
			安装依赖
				cd my-project
				npm install
				npm run dev
2.vue简介
	》vue.js
		是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，vue采用自底向上增量开发的设计。vue的核心库只关注
		视图层，并且易于学习，非常容易与其他库或已有项目整合。另一方面，vue完全有能力驱动采用单文件组件和vue生态系统
		支持的库开发复杂的单页面应用。
		vue的目标是通过尽可能简单的API实现响应式的数据绑定和组合的视图组件
	》使用
		》引入vue.js文件
			<script src="https://unpkg.com/vue/dist/vue.js"></script>
		》声明式渲染
			vue的核心是一个允许采用简洁的模板语法来声明式的将数据渲染进DOM的系统
			》绑定数据
				<div id='app'>
					{{message}}
				</div>
				var app=new Vue({
					el:'#app',
					data:{
						message:'Hello Vue'
					}
				});
				所有元素都是"响应式的"即双向绑定的
			》绑定DOM元素的属性
				<div id='app'>
					<span v-bind:title='message'>绑定属性</span>
				</div>
				var app=new Vue({
					el:'#app',
					data:{
						message:"绑定属性"+new Date()
					}
				});
				v-bind属性被称为指令。指定带有前缀v-表示他们是vue提供的特殊属性。它们会在渲染过的DOM上应用
				特殊的响应式行为。这个指令表示将这个元素节点的title属性和vue实例的message属性绑定到一起
			》条件与循环
				》控制切换一个元素的显示
					<div id='app'>
						<p v-if='seen'>出现</p>
					</div>
					var app=new Vue({
						el:'#app',
						data:{
							seen:true//通过该值来实现显示隐藏  true显示 false隐藏
						}
					});
					vue提供了一个强大的过度效果系统，可以在vue插入、删除元素时自动应用过度效果
				》v-for指令可以绑定数据到数组来渲染一个列表
					<div id='app'>
						<ol>
							<li v-for='todo in todos'>
								{{todo.text}}
							</li>
						</ol>
					</div>	
					var app=new Vue({
						el:'#app',
						data:{
							todos:[
								{text:'js'},
								{text:'Vue'}
								{text:'Build'}
							]
						}
					});
				》处理用户输入
					为了让用户和你的应用进行互动，我们可以用v-on指令绑定一个监听事件用于调用我们
					vue实例中定义的方法
					<div id='app'>
						<p>{{message}}</p>
						<button v-on:click='reverseMessage'>Reverse Message</button>
					</div>
					var app=new Vue({
						el:'#app',
						data:{
							message:'Hello Vue.js!'
						}
						methods:{
							reverseMessage:function(){
								this.message=this.message.split('').reverse().join('');
							}
						}
					});
				》Vue提供了v-model指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧
					<div id='app'>
						<p>{{message}}</p>
						<input v-model='message'/>
					</div>
					var app=new Vue({
						el:'#app',
						data:{
							message:'Hello Vue'
						}
					});
				》用组件构建应用
					组件系统是Vue.js另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们
					考虑到这点，几乎任意类型的应用界面都可以抽象为一个组件树
					》在Vue里，一个组件实质上是一个拥有预定义选项的一个Vue实例
						//定义一个todo-item组件
						Vue.component('todo-item',{
							props:['todo'],//接收从父作用域传到子组件的数据
							template:'<li>{{todo.text}}</li>'
						});
					》可以在另一个组件模板中写入它
						<ol id='app'>
							//通过v-bind指令将todo传到每一个重复的组件中
							<todo-item v-for='item in groceryList' v-bind:todo='item'></todo-item>
						</ol>
					》var app=new Vue({
						el:'#app',
						data:{
							groceryList:[
								{ text: 'Vegetables' },
								{ text: 'Cheese' },
								{ text: 'Whatever else humans are supposed to eat' }
							]
						}
					  });
				》与自定义元素的关系
					vue组件非常类似与自定义元素，它是web组件规范的一部分。
					》Web组件规范仍然远未完成，并且没有浏览器实现，相比之下，vue组件不需要任何补丁，并且在所有支持的浏览器之下表现一致
					  必要时，vue组件也可以放在原生自定义元素之内
					》vue组件提供了原生自定义元素所不具备的一些重要功能，比如组件间的数据流，自定义事件系统，以及动态的，带特效的组件替换
3.Vue实例
	》构造器
		每个vue.js应用都是通过构造函数Vue创建一个Vue的根实例启动的
			var vm=new Vue({
				...
			});
			虽然没有完全遵循MVVM模式，Vue的设计无疑收到了它的启发。因此该文档中经常会使用vm这个变量名表示
			Vue实例。
		在实例化Vue时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。
		可以拓展Vue构造器，从而用预定义选项创建可复用的组件构造器
			var MyComponent=Vue.extend({
				//扩展选项
			});
			var myComponent=new MyComponent();
			其实所有的Vue组件都是被扩展的Vue实例
	》属性与方法
		每个Vue实例都会代理其data对象里所有的属性
		var data={a:1}
		var vm=new Vue({
			data:data
		});
		vm.a===data.a//true
		注意只有这些被代理的属性是响应式的。如果在实例创建之后添加的新的属性到实例上，它不会触发视图更新。
		》除了data属性，Vue实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀，以便与代理的data属性区分
			var data={a:1}
			var vm=new Vue({
				el:'#example',
				data:data
			});
			vm.$data===data;//true
			var.$el===document.getElementById('example');//true
			vm.$watch('a',function(newVal,oldVal){
				//这个回调将在vm.a改变后调用
			});
			注意：不要在实例属性或回调函数中，如vm.$watch('a',newval=>this.myMethod())使用箭头函数。因为
			箭头函数绑定父上下文，所以this不会像预想的一样是Vue实例。
	》实例生命周期
		每个Vue实例再被创建之前都要经过一系列的初始化过程。如：实例需要配置数据观测data observer、编译模板、
		挂载实例到DOM，然后在数据变化时更新DOM。在这个过程中，实例也会调用一些生命周期钩子，这就给我们提供了执行自定义
		逻辑的机会，如created这个钩子在实例被创建之后被调用
			var vm=new Vue({
				data:{
					a:1
				},
				created:function(){
					console.log('a is:'+this.a);
				}
			});
			也有一些其他的钩子，在实例生命周期的不同阶段调用，如mounted updated destroyed。钩子的this指向调用它的
			Vue实例。Vue是没有控制器的概念的。组件的自定义逻辑可以分布在这些钩子中。
			生命周期图：
				new Vue()
				    |-beforeCreate
				Observe Data
				    |
				Init Events
				    |-created
				has 'el' option?--No--
				    |yes	     |when vm.$mount(el) is called
				has 'template' option?
				        |
				    yes- -No
Compile template into render function|    |Compile el's outerHTML as template
					|-beforeMount
				create vm.$el and replace 'el' with it
				        |-mounted
					|		   beforeUpdate--(Virtual DOM re-render and patch)
					|		    |				|
				     Mounted--when data changes			     updated
					|
				when vm.$destroy() is called
					|-beforeDestroy
				Teardown watchers,child components and event listeners
					|
				    destroyed--destroyed
4.模板语法
	    vue使用了基于html的模板语法，允许开发者声明式的将DOM绑定至底层vue实例的数据。所有vue的模板都是合法html
	所以能被遵循规范的浏览器和html解析器解析
	    在底层的实现上，vue将模板编译成虚拟DOM渲染函数。结合响应系统，在应用状态改变时，vue能够智能地计算出重新渲染
	组件的最小代码并引用到DOM操作上
	    如果熟悉虚拟DOM并且偏爱js的原始力量，你也可以不用模板，直接写渲染render函数，使用可选的jsx语法。
	》插值
		》文本
			数据绑定最常见的形式就是使用'Mustache'语法 双大括号的文本插值
				<span>Message:{{msg}}</span>
				Mustache标签将会被替代为对应数据对象上msg属性的值。无论何时绑定的数据对象上msg属性发生了
				改变，插值处的内容都会更新
			》v-once指令，能执行一次性插值，当数据改变时，插值处的内容不会更新。这会影响到该节点上所有的数据绑定
				<span v-once>This will never change:{{msg}}</span>
		》纯html
			双大括号会将数据解释为纯文本，而非html。为了输出真正的html，需要使用v-html
				<div v-html='rawhtml'></div>
			被插入的内容都会被当做html--数据绑定会被忽略。注意，你不能使用v-html来复合局部模块，因为vue不是基于
			字符串的模板引擎。组件更适合担任UI重用与复合的基本单元
		》属性
			Mustache不能在html属性中使用，应使用v-bind指令
				<div v-bind:id='dynamicId'></div>
			这对布尔值的属性也有效--如果条件被求值为false的话该属性会被移除
				<button v-bind:disabled='someDynamicCondition'>Button</button>
		》使用js表达式
			实际上，对于所有的数据绑定，Vue.js都提供了完全的js表达式支持
				{{number +1}}
				{{ok?'yes':'No'}}
				{{message.split('').reverse().join('')}}
				<div v-bind:id="'list-' + id"></div>
			这些表达式会在所属的vue实例的数据作用域下作为js被解析。有个限制就是，每个绑定都只能包含"单个表达式"
			下面实例无效：
				{{var a=1}}
				{{if (ok) {return message}}}
	》指令
		指令DirectIves是带有v-前缀的特殊属性。指令属性的是预期是单一的js表达式(除了v-for)。指令的作用就是
		当其表达式的值改变的时相应地将某些行为应用到DOM上。
			<p v-if='seen'>Now you see me</p>
		这里v-if指令将根据表达式seen的值的真假来移除/插入<p>元素
		》参数
			一些指令能接受一个参数，在指令后以冒号":"指明。如v-bind指令用来相应地更新html属性
				<a v-bind:href='url'></a>
			在这里href是参数，告知v-bind指令将该元素的href属性与表达式url的值绑定
			》v-on指令用于监听DOM事件
				<a v-on:click='doSomething'></a>
		》修饰符
			修饰符Modifiers是以半角句号'.'指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。
			如：.prevent修饰符，告诉v-on指令对于触发的事件调用event.preventDefault()
			<form v-on:submit.prevent='onSubmit'></form>
		》过滤器
			Vue允许自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在mustache插值的尾部，由
			"管道符"指示
			{{message | capitalize}}
			<div v-bind:id='rawId | formatId'></div>
			vue2.x中，过滤器只能在mustache绑定和v-bind表达式中使用，因为过滤器设计目的就是用于文本转换。为了
			在其他指令中实现更复杂的数据交换，应该使用计算属性
			过滤器函数总接受表达式的值作为第一个参数
				new Vue({
					filters:{
						capitalize:function(value){
							if(!value){return '';}
							return value.toUpperCase();
						}
					}
				});
			》过滤器可以串联
				{{message | filterA |filterB}}
			》过滤器是js函数，因此可以接受参数
				{{message | filter('arg1',arg2)}}
				这里字符串'arg1'将传给过滤器作为第二个参数，arg2表达式的值将被求值然后传给过滤器作为第三个参数
	》缩写
		v-前缀在模板中是作为一个表示Vue特殊属性的明显标识。当你使用vue为现有的标记添加动态行为时，它会很有用，但对于一些经常
		使用的指令来说有点繁琐。同时当搭建vue管理所有模块的SPA时，v-前缀也变得没那么重要了。因此vue为两个最为常见的命令提供了
		特别的缩写
			》v-bind缩写
				<a v-bind:href='url'></a>
				<a :href='url'></a>
			》v-on缩写
				<a v-on:click='doSomething'></a>
				<a @click='doSomething'></a>
5.计算属性
	在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护
	如：
		<div id='example'>
			{{message.split('').reverse().join('')}}
		</div>
		在这种情况下，模板不再简单和清晰。在实现反向显示message之前，你应该确认它。
		所以任何复杂逻辑你都应当使用"计算属性"
	》案例
		<div id='example'>
			<p>Original message:"{{message}}"</p>
			<p>Computed reversed message:"{{reversedMessage}}"</p>
		</div>
		var vm=new Vue({
			el:"#example",
			data:{
				message:"hello"
			},
			computed:{
				reversedMessage:function(){//一个计算属性getter
					return this.message.split('').reverse().join('')
				}
			}
		});
		这里我们声明了一个计算属性reverseMessage。我们提供的函数将用作属性vm.reverseMessage的getter。
		vm.reversedMessage的值始终取决于vm.message的值
		你可以像绑定普通属性一样在模板中绑定计算属性。vue知道vm.reversedMessage依赖于vm.message。因此当
		vm.message发生改变的时候，依赖于vm.reversedMessage的绑定也会更新。而且最妙的是我们声明式的创建这
		种依赖关系：计算属性的getter是干净无副作用的，因此也是易于测试和理解的
	》计算缓存 VS Methods
		当然我们通过调用表达式中的method来达到同于的效果
		<p>Reversed message:"{{reverseMessage()}}"</p>
		methods:{
			reverseMessage:function(){
				return this.message.split('').reverse.join('');
			}
		}
		不经过计算属性，我们可以在method中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。
		然而，不同的是"计算属性是基于它的依赖缓存"。计算属性只有在它的相关依赖发生改变的时候才会重新取值。这就意味着
		只要message没有发生改变，多次访问reverseMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。这也
		同样意味着如下计算属性将不会更新，因为它不是响应式依赖。相比而言，每当重新渲染的时候，method调用总会执行函数。
	》计算属性 VS watched Property
		vue提供了一个方法$watch，它用于观察vue实例上的数据变动。当一些数据需要根据其它数据变化时，$watch很诱人--特别是
		如果你来自AngularJs。不过通常更好的办法是使用计算属性而不是一个命令式的$watch回调。
			//watch 命令式的 重复的
			<div id='demo'>{{fullName}}</div>
			var vm=new Vue({
				el:'#demo',
				data:{
					firstName:"Foo",
					lastName:"Bar",
					fullName:"Foo Bar"
				},
				watch:{
					firstName:function(val){
						this.fullName=val+' '+this.lastName;
					},
					lastName:function(val){
						this.fullName=this.firstName+' '+val;
					}
				}
			});
			//计算属性
			var vm=new Vue({
				el:'#demo',
				data:{
					firstName:"Foo",
					lastName:"Bar"
				},
				computed:{
					fullName:function(){
						return this.firstName+" "+this.lastName;
					}
				}
			});
	》计算setter
		计算属性默认只有getter，不过在需要的时候也可以提供一个setter
		computed:{
			fullName:{
				get:function(){
					return this.firstName+" "+this.lastName;
				},
				set:function(newValue){
					var names=newValue.split(' ');
					this.firstName=names[0];
					this.lastName=names[names.length-1];
				}
			}
		}
		现在运行vm.fullName='John Doe'时，setter会被调用，vm.firstName和vm.lastName也会对应更新
	》观察Watchers
		虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的watcher。这是为什么vue提供了一个更通用的方法
		通过watch选项来响应数据的变化。当你需要在数据变化响应时，执行"异步操作或开销较大的操作"，这是很有用的。
		》案例
			<div id='watch-example'>
				<p>
					Ask a yes/no question:
					<input v-model='question'/>
				</p>
				<p>{{answer}}</p>
			</div>
			<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
			<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
			<script>
				var watchExampleVM=new Vue({
					el:"#watch-example",
					data:{
						question:'',
						answer:'I cannot give you an answer until you ask a question!'
					},
					watch:{
						//如果question发生改变，这个函数会运行
						question:function(newQustion){
							this.answer='Waiting for you to stop typing...';
							this.getAnswer();
						}
					},
					methods:{
						getAnswer:_.debounce(//是一个通过lodash限制操作频率的函数即ajax请求直到用户输入完毕才会发出
							function(){
								var vm=this;
								if(this.question.indexOf('?')===-1){
									vm.answer='Questions usually contain a question mark. ;-)';
									return;
								}
								vm.answer = 'Thinking...'
								axios.get('https://yesno.wtf/api')
								  .then(function (response) {
								    vm.answer = _.capitalize(response.data.answer)
								  })
								  .catch(function (error) {
								    vm.answer = 'Error! Could not reach the API. ' + error
								  })
							},
							500//我们为用户停止输入等待的毫秒数
						);
					}
				});
			</script>
			在这个实例中，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并且在我们得到最终结果前，
			设置中间状态。这是计算属性无法做到的。
6.class与style绑定
	数据绑定一个常见的需求是操作元素的class列表和它的内联样式。因为他们都是属性，我们可以用v-bind处理它们：只需要计算
	出表达式最终的字符串。不过字符串的拼接麻烦又易错。因此在v-bind用于class和style时，vue专门增强了它。表达式的结果类型
	除了字符串之外，还可以是对象或数组
	》绑定HTML Class
		》对象语法 我们可以传给v-bind:class一个对象以动态的切换class
			<div v-bind:class='{active:isActive}'></div>
			上面的语法表示class active的更新将取决于isActive是否为真值
			》我们也可以在对象中传入更多属性用来动态切换多个class，此外，v-bind:class指令可以与普通的class属性共存。
				<div 
					class='static'
					v-bind:class="{active:isActive,'text-danger':hasError}"
				></div>
				data:{
					isActive:true,
					hasError:false
				}
				渲染结果为：
					<div class="static active"></div>
					当isActive或hasError变化时，class列表将相应地更新。如hasError的值为true，class列表将
					变为"static active text-danger"
			》也可以直接绑定数据里面的一个对象
				<div v-bind:class='classObj'></div>
				data:{
					classObj:{
						active:true,
						'text-danger':false
					}
				}
				渲染结果和上面的一样
			》也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式
				<div v-bind:class='classObj'></div>
				data:{
					isActive:true,
					error:null
				}
				computed:{
					classObj:function(){
						return {
							active:this.isActive && !this.error,
							'text-danger':this.error && this.error.type==='fatal'
						}
					}
				}
		》数组语法--可以把一个数组传给v-bind:class,以应用一个class列表
			<div v-bind:class='[activeClass,errorClass]'></div>
			data:{
				activeClass:"active",
				errorClass:"text-danger"
			}
			渲染为：<div class='active text-danger'></div>
			》如果想根据条件切换列表中的class 可以用三元表达式
				<div v-bind:class="[isActive?activeClass:'',errorClass]"></div>
				只有当isActive为true时添加activeClass
			》当有多个条件class时，可以在数组语法中使用对象语法
				<div v-bind:class="[{active:isActive},errorClass]"></div>
		》用在组件上
			当你在一个定制的组件上用到class属性时，这些类将被添加到根元素上，这个元素上已经存在的类不会被覆盖
				Vue.component('my-component',{
					template:"<p class='foo bar'>Hi</p>"
				});
				》在使用它的时候添加class
					<my-component class='baz boo'></my-component>
				最终被渲染为
					<p class='foo bar baz boo'></p>
				》适用于绑定的html class
					<my-component v-bind:class='{active:isActive}'></my-component>
					//当isActive为true的时候，html将被渲染成为：
					<p class='foo bar active'></p>
	》绑定内联样式
		》对象语法
			v-bind:style的对象语法十分直观--看着非常像css，其实它是一个js对象。css属性名可以用驼峰式或短横分隔
			命名。
			<div v-bind:style='{color:activeColor,fontSize:fontSize+"px"}'></div>
			data:{
				activeColor:"red",
				fontSize:30
			}
			直接绑定到一个样式对象通常更好，让模板更清晰
				<div v-bind:style='styleObj'></div>
				data:{
					styleObj:{
						color:'red',
						fontSize:'13px'
					}
				}
			//同样的，对象语法常常结合返回对象的计算属性使用
		》数组语法
			v-bind:style的数组语法可以将多个样式对象应用到一个元素上
			<div v-bind:style='[styleObj1,styleObj2]'></div>
		》自动添加前缀
			当v-bind:style使用需要特定前缀的css属性时，如transform，vue会自动侦测并添加相应的前缀
7.条件渲染
	》v-if
		在字符串模板中，如Handlebars写一个条件块
			{{#if ok}}
				<h1>Yes</h1>
			{{/if}}
		在Vue，我们使用v-if指令实现同样的功能
			<h1 v-if='ok'>Yes</h1>
			<h1 v-else>No</h1>
		》<template>中v-if条件组
			因为v-if是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个
			<template>元素当做包装元素，并在上面使用v-if，最终的渲染结构不会包含它
			<template v-if='ok'>
				<h1>Title</h1>
				<p>Paragraph1</p>
				<p>Paragraph2</p>
			</template>
	》v-else
		可以用v-else指令给v-if添加一个"else"块
			<div v-if='Math.random()>.5'>
				Sorray
			</div>
			<div v-else>
				Not sorry
			</div>
			注意：v-else元素必须紧跟在v-if元素或v-else-if的后面--否则它不能被识别
	》v-else-if  2.1.0新增
		用作v-if块，可以链式的多次使用
			<div v-if='type==="A"'>A</div>
			<div v-else-if='type==="B"'>B</div>
			<div v-else-if='type==="C"'>C</div>
			<div v-else>
				Not A/B/C
			</div>
			注意：与v-else相似，v-else-if必须跟在v-if或v-else-if之后
	》使用key控制元素的可重用
		vue尝试尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使用vue更快之外还可以得到一些好处
			<template v-if='loginType==="username"'>
				<label>Username</label>
				<input placeholder="Enter your username"/>
			</template>
			<template v-else>
				<label>Email</label>
				<input placeholder='Enter your email address'/>
			</template>
			在代码中切换loginType不会删除用户已经输入的内容，两个模块由于使用了相同的元素,<input>会被复用，仅仅是
			替换了他们的placeholder
			//这样也不总是符号实际需求，所以vue提供了一种方式让你可以自己决定是否要复用元素。你要做的是添加一个属性
			key,key必须带有唯一的值
				<template v-if='loginType ==="username"'>
					<label>Username</label>
					<input placeholder='Enter your username' key='username-input'/>
				</template>
				<template v-else>
					<label>Email</label>
					<input placeholder='Enter your email address' key='email-input'/>
				</template>
				//现在输入文本将会在每次切换时重新渲染
				//注意：<label>元素仍然会被复用，因为没有被添加key属性
	》v-show
		另一个根据条件展示元素的选项是v-show指令
			<h1 v-show='ok'>Hello</h1>
		不同的是有v-show的元素会始终渲染并保持在DOM中。v-show是简单的切换元素的css属性display
		注意：v-show不支持<template>语法
	》v-if VS v-show
		v-if是真实的条件渲染，因为它会确保条件块在切换当中是当地销毁与重建条件块内的事件监听器和子组件
		v-if也是惰性的。如果在初始渲染时条件为假，则什么也不做--在条件第一次变为真时才开始局部编译(编译会被缓存起来)
		相比之下，v-show简单很多，元素始终被编译并保留，只是简单地基于css切换

		一般来说v-if有更高的切换消耗而v-show有更高的初始渲染消耗。因此如果需要频繁切换使用v-show较好。如果在运行时
		条件不大可能改变则使用v-if较好
8.列表渲染
	》v-for
		我们用v-for指令根据一组数组的选项列表进行渲染。v-for指令需要以"item in items"形式的特殊语法，items是源数据数组
		并且item是数组元素迭代的别名
		》基本用法
			<ul id='example'>
				<li v-for="item in items">
					{{item.message}}
				</li>
			</ul>
			var example=new Vue({
				el:"#example",
				data:{
					items:[
						{message:'Foo'},
						{message:'Bar'}
					]
				}
			});
		》在v-for块中，我们拥有对父作用域属性的完全访问权限，v-for还支持一个可选的第二个参数为当前项的索引
			<ul id='example'>
				<li v-for="(item,index) in items">
					{{parentMessage}}-{{index}}-{{item.message}}
				</li>
			</ul>
			var example=new Vue({
				el:'#example',
				data:{
					parentMessage:"parent",
					items:[
						{message:"Foo"},
						{message:"Bar"}
					]
				}
			});
			//也可以用"of替代in"作为分隔符，因为它是最接近的js迭代器语法
				<div v-for='item of items'></div>
		》Template v-for
			如同v-if模板，你也可以用带有v-for的<template>标签来渲染多个元素块
			<ul>
				<template v-for='item in items'>
					<li>{{item.msg}}</li>
					<li class='divider'></li>
				</template>
			</ul>
		》对象迭代v-for
			也可以用v-for通过一个对象的属性来迭代
			<ul id='repeat-object' class='demo'>
				<li v-for='value in obj'>
					{{value}}
				</li>
			</ul>
			new Vue({
				el:'#repeat-object',
				data:{
					obj:{
						FirstName:"A",
						LastName:"B",
						Age:30
					}
				}
			});
			//也可以提供第二个参数作为键名
			<div v-for='(value,key) in obj'>
				{{key}}:{{value}}
			</div>
			//第三个参数为索引
			<div v-for='(value,key,index) in obj'>
				{{index}}:{{key}}:{{value}}
			</div>
			//注意：在遍历对象时，是按Object.keys()的结果遍历的，但是不能保证它的结果在不同的js引擎下是一致的
		》整数迭代v-for
			v-for也可以取整数。在这种情况下，它将重复多次模板
			<div>
				<span v-for='n in 10'>{{n}}</span>//需要在父层元素中创建了Vue实例才可以
			</div>
		》组件和v-for
			//在自定义组件里，你可以像任何普通元素一样用v-for
			<my-component v-for='item in items'></my-component>
			//然而它不能自动传递数据到组件里面，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们
			//要用到props属性
			<my-component 
				v-for='(item,index) in items'
				v-bind:item='item'
				v-bind:index='index'
			></my-component>
				//不自动注入item到组件里的原因是因为这使得组件会紧密耦合到v-for如何运作。在一些情况下，明确
				//数据的来源可以使得组件可重用
			》案例
				<div id='todo'>
					<input 
						v-model='newTodoText'
						v-on:keyup.enter='addNewTodo'
						placeholder='Add a todo'
					/>
					<ul>
						<li
							is='todo-item'
							v-for='(todo,index) in todos'
							v-bind:title='todo'
							v-on:remove='todos.splice(index,1)'
						></li>
					</ul>
				</div>
				Vue.component('todo-item',{
					template:`<li>{{title}}<button v-on:click="$emit('remove')">X</button></li>`,
					props:['title']
				})
				new Vue({
					el:'#todo',
					data:{
						newTodoText:'',
						todos:[
							'Do the dishes',
							'Take out the trash',
							'Mow the lawn'
						]
					},
					methods:{
						addNewTodo:function(){
							this.todos.push(this.newTodoText);
							this.newTodoText='';
						}
					}
				})
	》key
		当Vue用v-for正在更新已渲染过的列表时，它默认用'就地复用'策略。如果数据项的顺序被改变，Vue将不是移动
		DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
		这个类似Vue1.x的track-by='$index'
		这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时DOM状态(如表单输入值)的列表渲染输出
		为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的key
		属性。理想的key值是每项都有唯一id，这个特殊的属性相当于vue 1.x的track-by，但它的工作方式类似于一个属性，所以
		你需要用v-bind来绑定动态值
			<div v-for='item in items' :key='item.id'>
				<!--内容-->
			</div>
			//建议尽可能使用v-for来提供key，除非迭代DOM内容足够简单，或者你是故意要依赖于默认行为来获取性能提升。
			因为它是vue识别节点的一个通用机制，key并不特别与v-for关联，key还具有其他用途。
	》数组更新检测
		》变异方法
			Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：
				》push()
				》pop()
				》shift()
				》unshift()
				》splice()
				》sort()
				》reverse()
				如调用前面例子的items数组变异方法：example1.items.push({message:'Baz'});
		》重塑数组
			变异方法(mutation method),顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，
			如：filter(),concat(),slice()。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧
			数组。
			example.items=example.items.filter(function(item){
				return item.message.match(/Foo/)
			});
			你可能认为这将导致Vue丢弃现有DOM并重新渲染整个列表，幸运的是，事实并非如此。vue实现了一些智能启发式方法来
			最大化DOM元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。
			》注意事项
				由于js的限制，vue不能检查以下变动的数组:
					》当利用索引直接设置一个项时，如：vm.items[indexOfItem]=newVlaue;
						//为了避免上述情况，以下两种方式将达到vm.items[indexOfItem]=newValue效果
						//同时也将触发状态更新
							//vue.set
							Vue.set(example.items,indexOfItem,newValue);
							//Array.prototype.splice
							example.items.splice(indexOfItem,1,newValue);
					》当你修改数组的长度时，如：vm.items.length=newLength;
						//避免该情况，使用splice
						example.items.splice(newLength);
		》显示过滤/排序结果
			有时，想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序
			数组的计算属性
			如：
				<li v-for='n in evenNumbers'>{{n}}</li>
				data:{
					numbers:[1,2,3,4,5]
				}
				computed:{
					evenNumbers:function(){
						return this.numbers.filter(function(number){
							return number%2===0;
						});
					}
				}
			//或，当计算属性不适用的情况下，在嵌套v-for循环中使用method方法
				<li v-for='n in even(numbers)'>{{n}}</li>
				data:{
					numbers:[1,2,3,4,5]
				}
				methods:{
					even:function(numbers){
						return numbers.filter(function(number){
							return number%2===0;
						});
					}
				}
9.事件处理器
	》监听事件
		》可以用v-on指令监听DOM事件来触发一些js代码
			<div id='example'>
				<button v-on:click='counter+=1'>增加</button>
				<p>该按钮被点击了{{counter}}次。</p>
			</div>
			new Vue({
				el:'#example',
				data:{
					counter:0
				}
			});
		》方法事件处理器
			许多事件处理的逻辑都很复杂，所以直接把js代码写在v-on指令中是不可行的。因此v-on可以接受一个定义的
			方法来调用
			<div id='example'>
				<!-- greet 是下面定义的方法名-->
				<button v-on:click='greet'>Greet</button>
			</div>
			var example=new Vue({
				el:"example",
				data:{
					name:'vue.js'
				},
				methods:{//在methods对象中定义方法
					greet:function(event){
						//this在方法里指当前vue实例
						alert('Hello'+this.name+"!");
						//event是原生DOM事件
						alert(event.target.tagName);
					}
				}
			});
			//也可以用js直接调用方法
			example.greet()//'Hello Vue.js!'
		》内联处理器方法
			除了直接绑定到一个方法，也可以用内联js语句
			<div id='example'>
				<button v-on:click='say("hi")'>Say hi</button>
			</div>
			new Vue({
				el:"#example",
				methods:{
					say:function(message){
						alert(message);
					}
				}
			});
			//有时也需要在内联语句处理器中访问原生DOM事件。可以用特殊变量$event把它传入方法
			<button @click='warn("哈哈",$event)'>Submit</button>
			methods:{
				warn:function(msg,event){
					//现在我们可以访问原生事件对象
					if(event)event.preventDefault();
					alert(msg);
				}
			}
		》事件修饰符
			在事件处理程序中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在methods中轻松实现这点，
			但更好的方式是：methods只有纯粹的数据逻辑，而不是去处理DOM事件细节。
			为了解决这个问题Vue为v-on提供了事件修饰符，通过由点(.)表示的指令后缀来调用修饰符
			》.stop
			》.prevent
			》.capture
			》.self
			》.once
			//阻止单击事件冒泡
			<a v-on:click.stop='doThis'></a>
			//提交事件不再重载页面
			<form v-on:submit.prevent='onSubmit'></form>
			//修饰符可以串联
			<a v-on:click.stop.prevent='doThat'></a>
			//只有修饰符
			<form v-on:submit.prevent></form>
			//添加事件监听器时使用事件捕获模式
			<div v-on:click.capture='doThis'></div>
			//只当事件在该元素本身(而不是子元素)触发时触发回调
			<div v-on:click.self='doThat'></div>
			//2.1.4新增 .once--事件最多触发一次
			<a v-on:click.once='doThis'></a>
		》按键修饰符
			在监听键盘事件时，我们经常需要监测常见的键值。Vue允许为v-on在监听键盘事件时添加按键修饰符
			//只有在keyCode是13时调用vm.submit()
			<input v-on:keyup.13='submit'/>
			//记住所有的keyCode比较困难，所以Vue为最常见的按键提供了别名
			<input v-on:keyup.enter='submit'/>//同上
			//缩写语法
			<input @keyup.enter='submit'/>
			//全部的按键别名
				》.enter
				》.tab
				》.delete 捕获'删除'和'退格'键
				》.esc
				》.space
				》.up
				》.down
				》.left
				》.right
			//可以通过全局config.keyCodes对象自定义按键修饰符别名
				Vue.config.keyCodes.f0=96//可以通过v-on:keyup.f0使用
			》2.1.0新增
				可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应
				》.ctrl
				》.alt
				》.shift
				》.meta
				//Alt+c
				<input @keyup.alt.67='clear'/>
				//ctrl +click
				<div @click.ctrl='doSomething'></div>
		》为什么在html中监听事件？
			你可能注意到这种事件监听的方式违背了关注点分离的传统理念。不用担心的原因是所有的Vue事件处理方法
			和表达式都严格绑定在当前视图ViewModel上，它不会导致任何维护上的困难。
			实际上使用v-on的优势如下：
				》通过html模板能够轻松定位在js代码里面对应的方法
				》因为你无须在js里手动绑定事件，你的viewModel代码可以是非常纯粹的逻辑，和DOM完全解耦，更易于测试
				》当一个ViewModel被销毁时，所有的事件处理器都会自动删除。你无须担心如何自己清理它们
10.表单控件绑定
	》基础用法
		可以用v-model指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。它负责
		监听用户的输入事件以及更新数据。
		v-model并不关心表单控件初始化所生成的值。因为它会选择vue实例数据来作为具体的值。
		》文本
			<input v-model='message' placeholder='edit me'/>
			<p>Message is:{{message}}</p>
		》多行文本
			<p style='white-space:pre'>{{message}}</p>
			<textarea v-model='message' placeholder='add multiple lines'></textarea>
			//在文本区域(<textarea></textarea>)插值并不会生效，应用v-model来代替
		》复选框
			//单个勾选框，逻辑值
			<input type='checkbox' id='checkbox' v-model='checked'/>
			<label for='checkbox'>{{checked}}</label>
			//多个勾选框，绑定到同一个数组
			<input type='checkbox' id='jack' value='Jack' v-model='checkedNames'/>
			<label for='jack'>Jack</label>
			<input type='checkbox' id='john' value='John' v-model='checkedNames'/>
			<label for='john'>John</label>
			<p>Checked names:{{checkedNames}}</p>
			data:{
				checkedNames:[]
			}
		》单选按钮
			<input type='radio' id='one' value='One' v-model='picked'/>
			<label for='one'>One</label>
			<input type='radio' id='two' value='Two' v-model='picked'/>
			<label for='two'>Two</label>
			<span>Picked:{{picked}}</span>
		》选择列表
			》单选列表
				<select v-model='selected'>
					<option>A</option>
					<option>B</option>
					<option>C</option>
				</select>
				<span>Selected:{{selected}}</span>
			》多选列表--绑定到一个数组
				<select v-model='selected' multiple>
					<option>A</option>
					<option>B</option>
					<option>C</option>
				</select>
				<span>Selected:{{selected}}</span>
			》动态选项，用v-for渲染
				<select v-model='selected'>
					<option v-for='option in options' v-bind:value='option.value'>
						{{option.text}}
					</option>
				</select>
				<span>Selected:{{selected}}</span>
				new Vue({
					el:''
					data:{
						selected:"A",
						options:[
							{text:"one",value:"A"},
							{text:"two",value:"B"},
							{text:"three",value:"C"}
						]
					}
				});
	》绑定value
		对于单选按钮，勾选框以及选项列表选项，v-model绑定的value通常是静态字符串，对于勾选框是逻辑值
		<input type='radio' v-model='picked' value='a'/>//当选中时，'picked'为字符串'a'

		<input type='checkbox' v-model='toggle'/>//toggle为true或false

		<select v-model='selected'>//当选中时，selected为字符串'abc'
			<option value='abc'>ABC</option>
		</select>
		//但有时我们想绑定value到vue实例的一个动态属性上，这时可以用v-bind实现，并且这个属性的值可以不是字符串
			》复选框
				<input type='checkbox'
					v-model='toggle'
					v-bind:true-value='a'
					v-bind:false-value='b'
				/>
				//当选中时
					vm.toggle===vm.a
				//当没有选中时
					vm.toggle===vm.b
			》单选按钮
				<input type='radio' v-model='pick' v-bind:value='a'/>
				//当选中时 vm.pick===vm.a
			》选择列表设置
				<select v-model='selected'>
					<option v-bind:value='{number:123}'>123</option>
				</select>
				//当选中时
				typeof vm.selected //'object'
				vm.selected.number//123
	》修饰符
		》.lazy
			在默认情况下，v-model在input事件中同步输入框的值与数据即上述部分，但你可以添加一个修饰符lazy，
			从而转变为在change事件中同步
			<input v-model.lazy='msg'/>//在change而不是input事件中更新
		》.number
			如果想自动将用户的输入值转为Number类型，如果原值的转换结果为NaN则返回原值，可以添加number修饰符给
			v-model来处理输入值
			<input v-model.number='age' type='number'/>
			这通常很有用，因为在type='number'时，html中输入值也总是会返回字符串类型
		》.trim
			如果要自动过滤用户输入的首尾空格，可以添加trim修饰符v-model上过滤输入
			<input v-model.trim='msg'/>
	》v-model与组件
		html内建的input类型有时不能满足你的需求。还好vue的组件系统允许你创建一个具有自定义行为可复用的input类型。
		这些input类型甚至可以和v-model一起使用。
11.组件
	》什么是组件
		组件Component是vue最强大的功能之一。组件可以扩展html元素，封装可重用的代码。在较高层面上，组件是自定义元素，vue的编译器
		为它添加特殊功能。在有些情况下，组件也可以是原生html元素的形式，以is特性扩展。
	》使用组件
		》注册
			//要注册一个全局组件，你可以使用Vue.component(tagName,options);
				Vue.component('my-component',{
					//选项
				});
				//对于自定义标签名，Vue不强制要求遵循W3C规则(小写，并且包含一个短杆)，尽管遵循这个规则比较好
				//组件在注册之后，便可以在**父实例的模块**中以自定义元素<my-component></my-component>的形式使用，要确保
				在**初始化根实例之前**注册了组件
					<div id='example'>
						<my-component></my-component>
					</div>
					//注册
					Vue.component('my-component',{
						template:'<div>A custom component!</div>'
					});
					//创建根实例
					new Vue({
						el:"#example"
					});
					//渲染为
					<div id='example'>
						<div>A custom component!</div>
					</div>
			//局部注册
				不必在全局注册每个组件。通过使用组件实例选项注册，可以是组件仅在另一个实例/组件的作用域中可用
				var Child={
					template:"<div>A custom component!</div>"
				}
				new Vue({
					components:{
						'my-component':Child,//注册组件 该组件只在父模块中可用
					}
				});
				//这种封装也适用于其他可注册的Vue功能，如指令
		》DOM模板解析说明
			当使用DOM作为模板时，如将el选项挂载到一个已存在的元素上，你会受到html的一些限制，因为vue只有在浏览器解析和标准化html
			后才能获取模板内容。尤其像这些元素<ul> <ol> <table> <select>限制了能被它包裹的元素，<option>只能出现在其它元素的内部。
			//在定义组件中使用这些受限制的元素时会导致一些问题
				<table>
					<my-row>...</my-row>
				</table>
				//自定义组件<my-row>被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的is属性
					<table>
						<tr is='my-row'></tr>
					</table>
				//注意：如果您使用来自一下来源之一的字符串模板，这些限制将不适用
					》<script type='text/x-template'></script>
					》js内联模板字符串
					》.vue组件
					因此,有必要的话请使用字符串模板
		》data必须是函数
			使用组件时，大多数可以传入到vue构造器中的选项 可以在注册组件时使用，有个例外：data必须是函数。
				Vue.component('my-component',{
					template:"<span>{{message}}</span>",
					data:{
						message:'hello'
					}
				});
				//那么vue会在控制台发出警告，告诉你在组件中data必须是一个函数。最好理解这种规则的存在意义
					<div id='example'>
						<simple-counter></simple-counter>
						<simple-counter></simple-counter>
						<simple-counter></simple-counter>
					</div>
					var data={counter:0}
					Vue.component('simple-counter',{
						template:'<button v-on:click="counter += 1">{{counter}}</button>',
						data:function(){//data是一个函数，因此Vue不会警告，但是我们为每一个组件返回了同一个对象引用
							return data;
						}
					});
					new Vue({
						el:'#example'
					});
					//由于这三个组件共享了同一个data,因此增加一个counter会影响所有组件，我们可以通过为每个组件返回新的data
					//对象来解决这个问题
					data:function(){
						return {//现在每个counter都有它自己内部的状态了
							counter:0
						}
					}
		》构成组件
			组件意味着协同工作，通常父子组件会是这样的关系：组件A在它的模板中使用了组件B。它们之间必然需要相互通信：父组件
			要给子组件传递数据，子组件需要将它内部发生的事情告诉给父组件。然而在一个良好定义的接口中尽可能将父子组件解耦是
			很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也可以大幅度提高了组件的可维护性和可重用性。
			在vue中，父子组件的关系可以总结为props down,events up。父组件通过props向下传递数据给子组件，子组件通过events给
			父组件发送消息。
					Parent
					|    | Pass Props
			     Emit Events|   \|/
					 Child
	》Prop
		》使用Prop传递数据
			组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用props把数据传递给子组件。
			prop是父组件用来传递数据的一个自定义属性。**子组件需要显示地用props选项声明"prop"**:
				Vue.component('child',{
					props:['message'],//声明props
					//就像data一样，prop可以用在模板内
					//同样也可以在vm实例中像'this.message'这样使用
					template:"<span>{{message}}</span>"
				});
				//然后向它传入一个普通字符串
				<child message='hello !'></child>
		》camelCase VS kebab-case
			html特性不区分大小写。当使用**非字符串模板**时，prop的名字形式会从camelCase转为kebab-case(短横线隔开)
				Vue.component('child',{
					props:['myMessage'],//camelCase
					template:'<span>{{myMessage}}</span>'
				});
				<child my-message='hello !'></child>//kebab-case
				//如果你使用字符串模板时，就不用在意这些限制
		》动态Prop
			类似于v-bind绑定html特性到一个表达式，也可以用v-bind动态绑定props的值到父组件的数据中，每当父组件的数据变化时，
			该变化也会传递给子组件
				<div>
					<input v-model='parentMsg'/>
					<child v-bind:my-message='parentMsg'></child>
					//缩写
					<child :my-message='parentMsg'></child>
				</div>
		》字面量语法 VS 动态语法
			常犯的一个错误是使用字面量语法传递数值：
				<comp some-prop='1'></comp>//传递了一个字符串'1'
			因为它是一个字面prop,它的值以字符串'1'而不是以实际的数字传下去。
			如果想传递一个js数字，需要使用v-bind，从而让它的值被当做js表达式计算：
				<comp v-bind:some-prop='1'></comp>//传递实际的数字
		》单向数据流
			prop是单向绑定的：当父组件的属性变化时，将传递给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态
			这会让应用的数据流难以理解。
			另外每次父组件更新时，子组件的所有prop都会更新为最新值。这意味着你**不应该在子组件内部改变prop**。如果你这么做了，
			Vue会在控制台给出警告。
			通常有两种改变prop的情况：
				》prop作为初始值传入子组件之后只是将它的初始值作为本地数据的初始值使用
					//定义一个局部data属性，并将prop的初始值作为局部数据的初始值
					props:['initialCounter'],
					data:function(){
						return {counter:this.initialCounter}
					}
				》prop作为需要被转变的原始值传入
					//定义一个computed属性，此属性从prop的值计算得出
					props:['size'],
					computed:{
						normalizedSize:function(){
							return this.size.trim().toLowerCase();
						}
					}
				//注意：在js中的对象和数组是引用类型，指向同一个内存空间，如果prop是一个对象或数组，在子组件内部改变它
				//会影响父组件的状态
		》Prop验证
			组件可以为props指定验证要求。如果未指定验证要求，Vue会发出警告。当组件给其他人使用时，这很有用。
			prop是一个对象而不是字符串数组时，它包含验证要求：
				Vue.component('example',{
					props:{
						propA:Number,//基础类型检测，null表示任何类型都可以
						propB:[String,Number],//多种类型
						propC:{//必传 且是字符串
							type:String,
							required:true
						},
						propD:{//数字 有默认值
							type:Number,
							default:100
						},
						propE:{//数组或对象的默认值应当由一个工厂函数返回
							type:Object,
							default:function(){
								return {message:'hello'}
							}
						},
						propF:{//自定义验证函数
							validator:function(value){
								return value>10
							}
						}
					}
				});
				type可以是下面原生构造器：
					》String
					》Number
					》Boolean
					》Function
					》Object
					》Array
				type也可以是一个自定义构造器，使用 instanceof 检测
				当prop验证失败了，如果使用的是开发版本会抛出一条警告
	》自定义事件
		我们知道，父组件是使用props传递数据给子组件，但如果子组件要把数据传递回去，应该怎么做？那就是自定义事件
		》使用v-on绑定自定义事件
			每个Vue实例都实现了事件接口(Events interface)即：
				》使用$on(eventName)监听事件
				》使用$emit(eventName)触发事件
				注意：vue的事件系统分离自浏览器的EventTarget API。尽管它们的运行类似，
				      但是$on和$emit不是addEventListener和dispatchEvent的别名。
				      另外父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件。
			》案例
				<div id='counter-event'>
					<p>{{total}}</p>
					<button-counter v-on:increment='incrementTotal'></button-counter>
					<button-counter v-on:increment='incrementTotal'></button-counter>
				</div>
				Vue.component('button-counter',{
					template:"<button v-on:click='increment'>{{counter}}</button>",
					data:function(){
						return {
							counter:0
						}
					},
					methods:{
						increment:function(){
							this.counter +=1;
							this.$emit('increment');
						}
					}
				});
				new Vue({
					el:'#counter-event',
					data:{
						total:0
					},
					methods:{
						incrementTotal:function(){
							this.total+=1;
						}
					}
				});
				//给组件绑定原生事件
					有时候，可能想在某个组件的根元素上监听一个原生事件。可以使用.native修饰v-on
						<my-component v-on:click.native='doTheThing'></my-component>
		》使用自定义事件的表单输入组件
			自定义事件也可以用来创建自定义的表单输入组件，使用v-model来进行数据的双向绑定
				<input v-model='something'/>
				//上面仅是一个语法糖
				<input v-bind:value='something' v-on:input='something=$event.target.value'/>
				//所以在组件中使用时，它相当于下面的简写：
				<custom-input v-bind:value='something' v-on:input='something=arguments[0]'></custom-input>
			》所以要让组件的v-model生效，它必须：
				》接受一个value属性
				》在有新的value时触发input事件
			》案例
				<currency-input v-model='price'></currency-input>
				Vue.component('currency-input',{
					template:'<span>$<input ref="input" v-bind:value="value" v-on:input="updateValue($event.targket.value)"/></span>',
					props:['value'],
					methods:{
						updateValue:function(value){
							//删除两侧空格符并保留2个小数位
							var formattedValue=value.trim().slice(0,value.indexOf('.')+3);
							//如果值不统一，手动覆盖 以保持一致
							if(formattedValue !== value){
								this.$refs.input.value=formattedValue;
							}
							//通过input事件发出数值
							this.$emit('input',Number(formattedValue));
						}
					}
				});
		》非父子组件通信
			有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的Vue实例作为中央事件总线
				var bus=new Vue();
				//触发组件 A 中的事件
				bus.$emit('id-selected',1);
				//在组件B创建的钩子中监听事件
				bus.$on('id-selected',function(id){
					//...
				})
				//在更多复杂的情况下，应该考虑使用专门的 状态管理模式
	》使用Slot分发内容
		在使用组件时，常常要像这样组合它们
			<app>
				<app-header></app-header>
				<app-footer></app-footer>
			</app>
			注意：
				》<app></app>组件不知道它的挂载点会有什么内容。挂载点的内容是由<app>的父组件决定的
				》<app></app>组件很有可能有它自己的模板
			为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为*内容分发(或transclusion如果你熟悉ng)*
			vue实现了一个内容的分发API，参照了当我web组件规范草案，使用了特殊的<slot>元素作为原始内容的插槽。
		》编译作用域
			在深入内容分发API之前，我们先明确内容的编译作用域。假设模板为：
				<child-component>
					{{message}}//父组件的数据
				</child-component>
				组件作用域简单来说：父组件模板的内容在父组件作用域内编译，子组件模板的内容在子组件作用域内编译
				常见错误：视图在父组件模板内将一个指令绑定到子组件的属性/方法：
					//无效的
					<child-component v-show='someChildProperty'></child-component>
					//假定someChildProperty是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态
				》如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：
					Vue.component('child-component',{
						template:"<div v-show='someChildProperty'>Child<div>",//有效的，因为是在正确的作用域内
						data:function(){
							return {
								someChildProperty:true
							}
						}
					});
					//类似地，分发内容是在父组件作用域内编译
		》单个Slot
			除非子组件模板包含至少一个<slot>插口，否则父组件的内容将被丢弃。当子组件模板中只有一个没有属性的slot时，
			父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身。
			最初在<slot>标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时
			才显示备用内容。
				//my-component组件有下面模板
				<div>
					<h2>我是子组件标题</h2>
					<slot>
						只有在没有要分发的内容时才会显示
					</slot>
				</div>
				//父组件模板
				<div>
					<h1>我是父组件的标题</h1>
					<my-component>
						<p>这是初始化内容</p>
					</my-component>
				</div>
				//渲染结果
				<div>
				  <h1>我是父组件的标题</h1>
				  <div>
				    <h2>我是子组件的标题</h2>
				    <p>这是初始化内容</p>
				  </div>
				</div>
		》具名slot
			<slot>元素可以用一个特殊的属性name来配置如何分发内容。多个slot可以有不同的名字。
			具名slot将配置内容片段中有对应slot特性的元素。
			仍然可以有一个匿名slot，它是默认slot，作为找不到匹配的内容片段的备用插槽。如果没有默认的slot，
			这些找不到匹配的内容片段将被抛弃。
			》案例
				//app-layout组件
				<div class='container'>
					<header>
						<slot name='header'></slot>
					</header>
					<main>
						<slot></slot>
					</main>
					<footer>
						<slot name='footer'></slot>
					</footer>
				</div>
				//父组件模板
				<app-layout>
					<h1 slot='header'>标题</h1>
					<p>主要内容</p>
					<p slot='footer'>footer</p>
				</app-layout>
				//渲染为
				<div class="container">
				  <header>
				    <h1>这里可能是一个页面标题</h1>
				  </header>
				  <main>
				    <p>主要内容</p>
				  </main>
				  <footer>
				    <p>footer</p>
				  </footer>
				</div>
		》作用域插槽--2.1.0新增
			作用域插槽是一种特殊类型的插槽，用作使用一个(能够传递数据到)可重用模板替换已渲染元素
			在子组件中，只需要将数据传递到插槽，就像你将prop传递给组件一样：
				<div class='child'>
					<slot text='hello from child'></slot>
				</div>
			在父级中，具有特殊属性scope的<template>元素，表示它是作用域插槽的模板，scope的值对应一个临时变量名，此变量接受从子组件中
			传递的prop对象。
				<div class='parent'>
					<child>
						<template scope='props'>
							<span>hello from parent</span>
							<span>{{props.text}}</span>
						</template>
					</child>
				</div>
			//渲染结果
				<div class="parent">
				  <div class="child">
				    <span>hello from parent</span>
				    <span>hello from child</span>
				  </div>
				</div>
			》作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项
				<my-awesome-list :items='items'>
					<template  scope='props'>
						<li class='my-fancy-item'>{{props.text}}</li>
					</template>
				</my-awesome-list>
				//列表组件的模板
				<ul>
					<slot  v-for='item in items' :text='item.text'></slot>
				</ul>
	》动态组件
		多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的<component>元素，动态的绑定到它的is特性
			var vm=new Vue({
				el:'#example',
				data:{
					currentView:'home'
				}
				components:{
					home:{},
					posts:{},
					archive:{}
				}
			});
			<component v-bind:is='currentView'>
				//组件在vm.currentview变化是改变
			</component>
			//也可以直接绑定到组件对象上
			var Home={
				template:'<p>Welcome home !</p>'
			}
			var vm=new Vue({
				el:'#example',
				data:{
					currentView:Home
				}
			});
		》keep-alive
			如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染，为此可以添加一个keep-alive指令参数
				<keep-alive>
					<component :is='currentView'>
					//非活动组件将被缓存
					</component>
				</keep-alive>
	》杂项
		》编写可复用组件
			在编写组件时，记住是否要复用组件有好处。一次性组件根其他组件紧密耦合没关系。但是可复用组件应当定义一个清晰的公开接口。
			Vue组件的API来自三部分：props events  slots
				》Props允许外部环境传递数据给组件
				》Events允许组件触发外部环境的副作用
				》slots允许外部环境将额外的内容组合在组件中
			使用v-bind和v-on的简写语法，模板的缩进清楚且简洁
				<my-component>
					:foo='baz'
					:bar='qux'
					@event-a='doThis'
					@event-b='doThat'
					<img slot='icon'></img>
					<p slot='main-text'>Hello!</p>
				</my-component>
		》子组件索引
			尽管有props和events，但是有时仍然需要在js中直接访问子组件。为此可以使用ref为子组件指定一个索引ID
			<div id='parent'>
				<user-profile ref='profile'></user-profile>
			</div>
			var parent=new Vue({el:"#parent"});
			//访问子组件
			var child=parent.$refs.profile
			//当ref和v-for一起使用时，ref是一个数组或对象，包含相应的子组件
			注意：$refs只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案--应当避免在模板或计算属性中使用$refs。
		》异步组件
			在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事件更简单，vue允许将组件定义为一个工厂函数，动态地解析组件的定义。
			vue只在组件需要渲染时触发工厂函数，并把结果缓存起来，用于后面的再次渲染。
			Vue.component('async-example',function(resolve,reject){
				setTimeout(function(){
					resolve({
						template:"<div>I am async!</div>"
					});
				},1000);
			});
			//工厂函数接收一个resolve回调函数，在收到从服务器下载的组件定义时调用。也可以调用reject(reason)指示加载失败。这里setTimeout只是为了
			//演示，怎么获取组件完全由你决定
				Vue.component('async-webpack-example',function(resolve){
					require(['./my-async-component'],resolve);
				});
				//也可以使用webpack2+ES2015的语法返回一个Promise resolve函数
				Vue.component('async-webpack-example',()=>System.import('./my-async-component'));
		》组件命名约定
			当注册组件或props时，可以使用kebab-case camelCase 或TitleCase。Vue不关心这个
				components:{
					'kebab-cased-component':{}
					'camelCasedComponent':{}
					'TitleCasedComponent':{}
				}

			在html模板中，请使用kebab-case形式
				<kebab-cased-component></kebab-cased-component>
				<camel-cased-component></camel-cased-component>
				<title-cased-component></title-cased-component>
				//当使用字符串模式时，可以不受html的case-insensitive限制。这意味着实际上在模板中，你可以使用camelCase、TitleCase或kebab-case来引用
					<my-component></my-component>
					<myComponent></myComponent>
					<Mycomponent></Mycomponent>
				//如果组件未经slot元素传递内容，你甚至可以在组件名后面使用/使其自闭合
					<my-component />
				//当然这只是在字符串模式中有效。因为自闭的自定义元素是无效的html，浏览器原生的解析器也无法识别它。
		》递归组件
			组件在它的模板内可以递归地调用自己，不过只有当它有name选项时才可以
				name:"unique-name-of-my-component"
			//当你利用Vue.component全局注册了一个组件时，全局的ID作为组件的name选项，被自动设置
				Vue.component('unique-name-of-my-component',{
					//...
				});
			//如果你不谨慎，递归组件可能导致死循环
				name:'stack-overflow',
				template:"<div><stack-overflow></stack-overflow></div>"
				上面组件会导致一个错误'max stack size exceeded',所以要确保递归调用有终止条件。如递归调用时，使用v-if并让它最终返回false
		》Circular References Between Components 组件之间的环型引用
			//tree-folder组件
			<p>
				<span>{{folder.name}}</span>
				<tree-folder-contents :childern='folder.children'/>
			</p>
			//tree-folder-contents组件
			<ul>
				<li v-for='child in children'>
					<tree-folder v-if='child.children' :folder='child' />
					<span v-else>{{child.name}}</span>
				</li>
			</ul>
			beforeCreate:function(){
				this.$options.components.TreeFolderContents=require('./tree-folder-contents.vue');
			}
		》内联模板
			如果子组件有inline-template特性，组件将把它的内容当做它的模板，而不是把它当做分发内容。这让模板更灵活
				<my-component inline-template>
					<div>
					    <p>These are compiled as the component's own template.</p>
					    <p>Not parent's transclusion content.</p>
					 </div>
				</my-component>
				即 my-component标签的内容将成为该组件的模板，而它本身的模板将无效
			//inline-component让模板的作用域难以理解。最佳实践是使用template选项在组件内定义模板或在.vue文件中使用template元素
		》X-Templates
			另一种定义模板的方式是在js标签里使用text/x-template类型，并且指定一个id
			<script type='text/x-template' id='hello-world-template'>
				<p>hello hello hello</p>
			</script>
			Vue.component('hello-world',{
				template:'#hello-world-template'
			});
			//这在很多模板或小的应用中有用，否则应该避免使用，因为它将模板和组件的其他定义隔离了
		》使用v-once的低级静态组件
			尽管在Vue中渲染html很快，不过当组件中包含大量静态内容，可以考虑使用v-once将渲染结果缓存起来
				Vue.component('terms-of-service',{
					template:'<div v-once><h1>Terms of Service</h1>.....a lot of static content</div>'
				});
12.深入响应式原理
	Vue最显著的特性之一便是不太引人注意的响应式系统reactivity system。模型层model只是普通js对象，修改它则更新视图view。
	》如何追踪变化
		把一个普通js对象传给Vue实例的data选项，Vue将遍历此对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter。
		Object.defineProperty是仅Es5支持，且无法shim的特性，这也就是为什么Vue不支持IE8以及更低版本浏览器的原因。
		用户看不到getter/setter，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象
		时getter/setter的格式化并不同，所以你可能需要安装vue-devtools来获取更加友好的检查接口。
		每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，
		从而致使它关联的组件得以更新。
	》变化检查问题
		受现代js的限制以及废弃Object.observe，vue不能检测到对象属性的添加或删除。由于vue会在初始化实例时对属性执行getter/setter转化过程，所以属性
		必须在data对象上存在才能让vue转换它，这样才能让它是响应的。
			var vm=new Vue({
				data:{
					a:1,
				}
			});
			//vm.a是响应的
			vm.b=2;//是非响应的
		Vue不允许在已经创建的实例上动态添加新的根级响应式属性roo-level reactive property。然而它可以使用Vue.set(object,key,value);方法将响应属性
		添加到嵌套的对象上
			Vue.set(vm.someObject,'b',2);
		你还可以使用vm.$set实例方法，这也是全局Vue.set方法的别名
			this.$set(this.someObject,'b',2);
		有时你想向已有对象上添加一些属性，如：使用Object.assign()或_.extend()方法来添加属性。但是添加到对象上的新属性不会触发更新。在
		这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性
			//代替 Object.assign(this.someObj,{a:1,b:2});
			this.someObj=Object.assign({},this.someObj,{a:1,b:2});
	》声明响应式属性
		由于Vue不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值
			var vm=new Vue({
				data:{
					message:""//声明message为空字符串
				},
				template:"<div>{{message}}</div>"
			});
			//之后设置 message属性值
			vm.message='Hello'
			//如果你在data选项中未声明message，Vue将警告你渲染函数在试图访问的属性不存在
			//这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使得Vue实例在类型检查系统的帮助下运行的更高效。
			//而且在代码可维护性方面也有一点重要的考虑：data对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读
			//或其他开发人员阅读时更易于被理解
	》异步更新队列
		Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会一次
		推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后在下一个的事件循环'tick'中，Vue刷新队列并执行实际(已去重的)
		工作。Vue在内部尝试对异步队列使用原生的Promise.then和MutationObserver，如果执行环境不支持，会采用setTimeout(fn,0)代替。
		如：当你设置vm.someData='new value',该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个'tick'更新。多数情况下我们不需要
		关系这个过程，但是如果你想在DOM状态更新后做点什么，这就可能会有些困难。虽然vue通常鼓励开发人员沿着'数据驱动'的方式思考，避免直接接触DOM，但是
		有时我们确实要这么做。为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用Vue.nextTick(callback),这样回调函数在DOM更新完成后就会被调用。
			<div id='example'>{{message}}</div>
			var vm=new Vue({
				el:"#example",
				data:{
					message:"123"
				}
			});
			vm.message='new message';//更改数据
			vm.$el.textContent==='new message';//false;
			Vue.nextTick(function(){
				vm.$el.textContent==='new message'//true
			});
		//在组件内使用vm.$nextTick()实例方法特别方便，因为它不需要全局Vue,并且回调函数中的this将自动绑定到当前Vue实例上
			Vue.component('example',{
				template:"<span>{{message}}</span>",
				data:function(){
					return {
						message:'not updated'
					}
				},
				methods:{
					updateMessage:function(){
						this.message='updated';
						console.log(this.$el.textContent);//没有更新
						this.$nextTick(function(){
							console.log(this.$el.textContent);//更新完成
						});
					}
				}
			});
13.过渡效果
	》概述
		Vue在插入、更新或移除DOM时，提供多种不同方式的应用过度效果
		》在css过渡和动画中自动应用class
		》可以配合使用第三方css动画库，如Animate.css
		》在过渡钩子函数中使用js直接操作DOM
		》可以配合使用第三方js动画库，如Velocity.js
	》单元素/组件的过渡
		Vue提供了transition的封装组件，在下列情形中，可以给任何元素和组件添加entering/leaving过渡
			》条件渲染 v-if
			》条件展示 v-show
			》动态组件
			》组件根节点
		》案例
			<div id='demo'>
				<button @click='show=!show'>Toggle</button>
				<transition name='fade'>
					<p v-if='show'>hello</p>
				</transition>
			</div>
			new Vue({
				el:'#demo',
				data:{
					show
				}
			});
			.fade-enter-active,.fade-leave-active{
				transition:opacity .5s;
			}
			.fade-enter,.fade-leave-active{
				opacity:0
			}
			//元素封装成过渡组件之后，在遇到插入或删除时，Vue将
				》自动嗅探目标元素是否有css过渡或动画，并在合适时添加/删除css类名
				》如果过渡组件设置了过渡的js构造函数，会在相应的阶段调用钩子函数
				》如果没有找到js钩子并且也没有检查到css过渡/动画，DOM操作(插入、删除)在下一帧立即执行。
				注意：此指浏览器逐帧动画机制，与Vue的nextTick概念不同
		》过渡的css类名
			会有4个css类名在enter/leave的过渡中切换
			》v-enter:定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除
				opacity:0
			》v-leave:定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除
				opacity:1
			》v-enter-active:定义进入过渡的结束状态，在元素被插入时生效，在transition/animation完成之后移除
				opacity:0->1
			》v-leave-active:定义离开过渡的结束状态。在离开过渡被触发时生效，在transition/animation完成之后移除
				opacity:1->0
			对于这些在enter/leave过渡中切换的类名，v-是这些类名的前缀，使用<transition name='my-transition'></transition>
			可以重置前缀。如：v-enter替换为my-transition-enter
			v-enter-active和v-leave-active可以控制进入/离开过渡的不同阶段。
		》css过渡
			常用的过渡都是使用css过渡
			<div id='example'>
				<button @click='show = !show'>toggle</button>
				<transition name='slide-fade'>
					<p v-if='show'>hello</p>
				</transition>
			</div>
			new Vue({
				el:'#example',
				data:{
					show:true
				}
			});
			.slide-fade-enter-active{
				transition:all .3s ease;
			}
			.slide-fade-leave-active{
				transition:all .8s cubic-bezier(1.0,.5,.8,1.0);
			}
			.slide-fade-enter,.slide-fade-leave-active{
				transform:translateX(10px);
				opacity:0,
			}
		》css动画
			css动画用法同css过渡，区别是在动画中v-enter类名在节点插入DOM后不会立即删除，而是在animationend事件触发时删除
				<div id='example'>
					<button @click='show = ！show'>toggle show</button>
					<transition name='bounce'>
						<p v-if='show'>look at me!</p>
					</transition>
				</div>
				new Vue({
					el:'#example',
					data:{
						show:true
					}
				});
				.bounce-enter-active{
					animation:bounce-in .5s;
				}
				.bounce-leave-active{
					animation:bounce-out .5s;
				}
				@keyframes bounce-in{
					0%{
						transform:scale(0);
					}
					50%{
						transform:scale(1.5);
					}
					100%{
						transform:scale(1);
					}
				}
				@keyframes bounce-out{
					0%{
						transform:scale(1);
					}
					50%{
						transform:scale(1.5);
					}
					100%{
						transform:scale(0);
					}
				}
		
		》自定义过渡类名
			通过以下特性来自定义过渡类名：
				》enter-class
				》enter-active-class
				》leave-class
				》leave-active-class
			它们的优先级高于普通的类名，这对于Vue的过渡系统和其他第三方css动画库。如：Animate.css结合使用十分有用
			<link href="https://unpkg.com/animate.css@3.5.1/animate.min.css" rel="stylesheet" type="text/css">
			<div id='example'>
				<button @click='show = !show'>toggle</button>
				<transition
					name='custom-classes-transition'
					enter-active-class='animated tada'
					leave-active-class='animated bounceOutRight'
				>
					<p v-if='show'>hello</p>
				</transition>
			</div>
			new Vue({
				el:'#example',
				data:{
					show:true
				}
			});
		》同时使用Transitions和Animations
			Vue为了知道过渡的完成，必须设置相应的事件监听器，它可以是transitionend或animationed，这取决于给元素应用的css规则。
			如果你使用其中任何一种，Vue能自动识别类型并设置监听。
			但是，在一些场景中，你需要给同一个元素同时设置两种过渡效果，如：animation很快的被触发并完成了，而transition效果还没结束。
			在这种情况下，你就需要使用type特性并设置animation或transition来明确声明你需要的Vue监听的类型
		》js钩子
			可以在属性中声明js钩子
			<transition
				v-on:before-enter='beforeEnter'
				v-on:enter='enter'
				v-on:after-enter='afterEnter'
				v-on:enter-cancelled='enterCancelled'

				v-on:before-leave='beforeLeave'
				v-on:leave='leave'
				v-on:after-leave='afterLeave'
				v-on:leave-cancelled='leaveCancelled'
			>
			
			</transition>
			methods:{
				//进入中
				beforeEnter:function(el){
					//...
				}
				enter:function(el,done){//此回调函数是可选的设置与css结合时使用
				
				}
				afterEnter:function(el){
					//...
				}
				enterCancelled:function(el){
					//...
				}
				//离开
				beforeLeave:function(el){
					//...
				}
				leave:function(el,done){
					//...
					done()
				}
				afterLeave:function(el){
					//...
				}
				leaveCancelled:function(el){//leaveCancelled只用于v-show中
					//...
				}
			}
			这些钩子函数可以结合css transitions/animations使用，也可以单独使用。
			注意：
				当只用js过渡的时候，在enter和leave中，回调函数done是必须的。否则它们会被同步调用，过渡会立即完成
				推荐对于仅使用js过渡的元素添加v-bind:css='false',vue会跳过css的检查。这也是避免过渡过程中css的影响
			》使用Velocity.js案例
				<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
				<div id='example'>
					<button @click='show =! show'>toggle</button>
					<transition
						v-on:before-enter='beforeEnter'
						v-on:enter='enter'
						v-on:leave='leave'
						v-bind:css='false'
					>
						<p v-if='show'>Demo</p>
					</transition>
				</div>
				new Vue({
					el:'#example',
					data:{
						show:false
					},
					methods:{
						beforeEnter:function(el){
							el.style.opacity=0;
							el.style.transformOrigin='left';
						}
						enter:function(el,done){
							Velocity(el,{opacity:1,fontSize:'1.4em'},{duration:300});
							Velocity(el,{fontSize:'1em'},{complete:done});
						}
						leave:function(el,done){
							Velocity(el,{translateX:'15px',rotateZ:'50deg'},{duration:600});
							Velocity(el,{rotateZ:'100deg'},{loop:2});
							Velocity(el,{
								rotateZ:'45deg',
								translateY:'30px',
								translateX:'30px',
								opacity:0
							},{complete:done});
						}
					}
				});
		》初始渲染的过渡
			可以通过appear特性设置节点的在初始渲染的过渡
			<transition appear>
				//...
			</transition>
			//这里默认和进入和离开过渡一样，同样也可以自定义css类名
			<transition>
				appear
				appear-class='custom-apper-class'
				appear-active-class='custom-appear-active-class'
			</transition>
			//自定义js钩子
			<transition
				appear
				v-on:before-appear='customBeforeAppear'
				v-on:appear='customAppear'
				v-on:after-appear='customAfterAppear'
			>
			
			</transition>
		》多个元素的过渡
			对于原生标签可以使用v-if  v-else最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：
				<transition>
					<table v-if='items.length>0'></table>
					<p v-else>Sorry,no items fond.</p>
				</transition>
				//当有相同标签名的元素切换时，需要通过key特性设置唯一的值来标记以让Vue区分它们，否则Vue为了效率只会替换相同标签
				//内部的内容。即使在技术上没有必要，给在<transition></transition>组件中的多个元素设置key是一个更好的实践。
					<transition>
						<button v-if='isEditing' key='save'>
							Save
						</button>
						<button v-else key='edit'>
							Edit
						</button>
					</transition>
				//在一些场景中，也可以给通过给同一个元素的key特性设置不同的状态来代替v-if和v-else，上面案例重写为：
					<transition>
						<button v-bind:key='isEditing'>
							{{isEditing?'save':'edit'}}
						</button>
					</transition>
				//使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡
					<transition>
						<button v-if='docState === "saved"' key='saved'>Edit</button>
						<button key='edited' v-if='docState === "edited"'>Save</button>
						<button v-if='docState === "editing"' key='editing'>Cancel</button>
					</transition>
					//重写
					<transition>
						<button :key='docState'>{{buttonMessage}}</button>
					</transition>
					computed:{
						buttonMessage:function(){
							switch (docState){
								case 'saved': return 'Edit'
							        case 'edited': return 'Save'
							        case 'editing': return 'Cancel'
							}
						}
					}
				//过渡模式
					transition的默认行为是进入和离开同时发生，但是这不能满足所有要求，所以vue提供了过渡模式
					》in-out :新元素先进行过度，完成之后当前元素过渡离开
					》out-in ：当前元素先进行过度，完成之后新元素过渡进入
					案例：
					<transition name='fade' mode='out-in'>
					
					</transition>
		》多个组件的过渡
			多个组件的过渡简单很多，我们不需要使用key特性，我们只需要使用**动态组件**：
			<transition name='component-fade' mode='out-in'>
				<component v-bind:is='view'></component>//动态改变组件
			</transition>
			new Vue({
				el:'#transition-components-demo',
				data:{
					view:'v-a'
				},
				components:{
					'v-a':{
						template:'<div>Component A</div>'
					},
					'v-b':{
						template:'<div>Component B</div>'
					}
				}
			});
			.component-fade-enter-active, .component-fade-leave-active {
			  transition: opacity .3s ease;
			}
			.component-fade-enter, .component-fade-leave-active {
			  opacity: 0;
			}
		》列表过渡
			目前为止，关于过渡我们已经讲到了：
				》单个节点过渡
				》同时渲染多个节点中的一个
				那么怎么同时渲染整个列表，如使用 v-for在这种场景中使用<transiton-group>组件。
				<transition-group>组件的特点：
					》不同于<transition>它会以一个真实元素呈现：默认为一个<span>你也可以通过tag特性更换为其他元素
					》内部元素总是需要提供唯一的key属性值
			》列表的进入和离开过渡
				<div id='list-demo' class='demo'>
					<button @click='add'>Add</button>
					<button @click='remove'>Remove</button>
					<transition-group name='list' tag='p'>//指定用p标签作为列表容器 指定过渡名 list
						//为每一项指定key值
						<span v-for='item in items' :key='item' class='list-item'></span>
					</transition-group>
				</div>
				new Vue({
					el:'#list-demo',
					data:{
						items:[1,2,3,4,5,6,7,8,9],
						nextNum:10
					},
					methods:{
						randomIndex:function(){
							return Math.floor(Math.random()*this.items.length);
						},
						add:function(){
							this.items.splice(this.randomIndex(),0,this.nextNum++);
						},
						remove:function(){
							this.items.splice(this.randomIndex(),1);
						}
					}
				});
				.list-item {
				  display: inline-block;
				  margin-right: 10px;
				}
				.list-enter-active, .list-leave-active {
				  transition: all 1s;
				}
				.list-enter, .list-leave-active {
				  opacity: 0;
				  transform: translateY(30px);
				}
				//这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局位置
				//而不是平滑的过渡，我们需要解决这个问题
			》列表的位移过渡
				<transition-group>组件还有一个特殊之处，不仅可以定义进入和离开动画，还可以改变定位。
				要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。像之前的类名
				一样，可以通过name属性来自定义前缀，也可以通过move-class属性手动设置。
				v-move对于设置过渡的切换时机和过度曲线非常有用：
				<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
				<div id='flip-list-demo' class='demo'>
					<button @click='shuffle'>Shuffle</button>
					<transition-group name='flip-list' tag='ul'>
						<li v-for="item in items" :key='item'>
							{{item}}
						</li>
					</transition-group>
				</div>
				new Vue({
					el:'#flip-list-demo',
					data:{
						items:[1,2,3,4,5,6,7,8,9]
					},
					methods:{
						shuffle:function(){
							this.items=_.shuffle(this.items);
						}
					}
				});
				.flip-list-move{
					transition:transform 1s;
				}
				//将之前的案例 和 这个技术结合 使我们列表的一切变动都会有动画过渡
					<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
					<div id='list-complete-demo' class='demo'>
						<button @click='shuffle'>Shuffle</button>
						<button @click='add'>Add</button>
						<button @click='remove'>Remove</button>
						<transition-group name='list-complete' tag='p'>
							<span 
								v-for='item in items'
								:key='item'
								class='list-complete-item'
							>
								{{item}}
							</span>
						</transition-group>
					</div>
					new Vue({
						el:'#list-complete-demo'
						data:{
							items:[1,2,3,4,5,6,7,8,9],
							nextNum:10
						},
						methods:{
							randomIndex:function(){
								return Math.floor(Math.random() * this.items.length);
							},
							add:function(){
								this.items.splice(this.randomIndex(),0,this.nextNum++);
							},
							remove:function(){
								this.items.splice(this.randomIndex(),1);
							},
							shuffle:function(){
								this.items=_.shuffle(this.items);
							}
						}
					});
					.list-complete-item {
					transition: all 1s;
					display: inline-block;//注意：使用flip过渡的元素不能设置display:inline,作为替代方案可以设置为display:inline-block或放置于flex中
					margin-right: 10px;
					}
					.list-complete-enter, .list-complete-leave-active {
					opacity: 0;
					transform: translateY(30px);
					}
					.list-complete-leave-active {
					position: absolute;
					}
					//flip动画不仅可以实现单列过渡，多维网格的过渡也是同样的简单
			》列表的渐进过渡
				通过data属性与js通信，就可以实现列表的渐进过渡
				<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
				<div id='staggered-list-demo'>
					<input v-model='query'/>
					<transition-group
						name='staggered-fade'
						tag='ul'
						:css='false'
						@before-enter='beforeEnter'
						@enter='enter'
						@leave='leave'
					>
						<li
							v-for='(item,index) in computedList'
							:key='item.msg'
							:data-index='index'
						>
							{{item.msg}}
						</li>
					</transition-group>
				</div>
				new Vue({
					el:'#staggered-list-demo'
					data:{
						query:'',
						list:[
							{msg:"Brece Lee"},
							{msg:"Jackie Chan"},
							{msg:"Chunk Norris"},
							{msg:"Jet Li"},
							{msg:"Kung Fury"}
						]
					},
					computed:{
						computedList:function(){
							var  vm=this;
							return this.list.filter(function(item){
								return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1;
							});
						}
					},
					methods:{
						beforeEnter:function(el){
							el.style.opacity=0;
							el.style.height=0;
						},
						enter:function(el,done){
							var deley=el.dataset.index * 150;
							setTimeout(function(){
								Velocity(
									el,
									{
										opacity:1,
										height:'1.6em'
									}
									,{
										complete:done
									}
								);
							},delay);
						},
						leave: function (el, done) {
						      var delay = el.dataset.index * 150
						      setTimeout(function () {
							Velocity(
							  el,
							  { opacity: 0, height: 0 },
							  { complete: done }
							)
						      }, delay)
						    }
					}
				});
		》可复用的过渡
			过渡可以通过Vue的组件系统实现复用。要创建一个可复用的过渡组件，你需要做的就是将<transition>或<transition-group>作为根组件，然后将任何子组件放置在其中就可以了。
			//使用template
			Vue.component('my-special-transition',{
				template:`
					<transition
						name='very-special-transition'
						mode='out-in'
						@before-enter='beforeEnter'
						@afterEnter='afterEnter'
					>
						<slot></slot>
					</transition>
				`,
				methods:{
					beforeEnter:function(el){
					
					},
					afterEnter:function(el){
					
					}
				}
			});
			//函数组件实现
			Vue.component('my-special-transition',{
				functional:true,
				render:function(createElement,context){
					var data={
						props:{
							name:'very-special-transition',
							mode:'out-in'
						},
						on:{
							beforeEnter:function(el){
							
							},
							afterEnter:function(el){
							
							}
						}
					}
					return createElement('transition',data,context.children);
				}
			})
		》动态过渡
			在Vue中即使是过度也是数据驱动的，动态过渡最基本的例子是通过name特性来绑定动态值的。
			<transition :name='transitionName'>
			
			</transition>
			//当你想用Vue的过渡系统来定义css过渡或动画在不同过渡间切换会非常有用。
			所有的过渡特性都是动态绑定的，它不仅仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。
			这意味着可以根据组件的状态通过js过渡设置不同的过渡效果。
			<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
			<div id='dynamic-fade-demo'>
				Fade In: <input type='range' v-model='fadeInDuration' min='0' :max='maxFadeDuration'/>
				Fade Out: <input type='range' v-model='fadeOutDuration' min=0 :max='maxFadeDuration'/>
				<transition
					:css='false'
					@before-enter='beforeEnter'
					@enter='enter'
					@leave='leave'
				>
					<p v-if='show'>Hello</p>
				</transition>
				<button @click='stop =true'>Stop it</button>
			</div>
			new Vue({
				el:'#dynamic-fade-demo',
				data:{
					show:true,
					fadeInDuration:1000,
					fadeOutDuration:1000,
					maxFadeDuration:1500,
					stop:false
				},
				methods: {
				    beforeEnter: function (el) {
				      el.style.opacity = 0
				    },
				    enter: function (el, done) {
				      var vm = this
				      Velocity(el,
					{ opacity: 1 },
					{
					  duration: this.fadeInDuration,
					  complete: function () {
					    done()
					    if (!vm.stop) vm.show = false
					  }
					}
				      )
				    },
				    leave: function (el, done) {
				      var vm = this
				      Velocity(el,
					{ opacity: 0 },
					{
					  duration: this.fadeOutDuration,
					  complete: function () {
					    done()
					    vm.show = true
					  }
					}
				      )
				    }
				  }
			});	
14.过渡状态
	Vue的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢。如：
		》数字和运算
		》颜色的显示
		》SVG节点的位置
		》元素的大小和其他的属性
		所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合Vue的响应式和组件系统，
		使用第三方库来实现切换元素的过渡状态。
	》状态动画与watcher
		通过watcher我们能监听到任何数值属性的数值更新，可能听起来很抽象，所以让我们先来看看使用Tweenjs的一个例子：
		<script src="https://unpkg.com/tween.js@16.3.4"></script>
		<div id='animated-number-demo'>
			<input v-model.number='number' type='number' step='20'/>
			<p>{{animatedNumber}}</p>
		</div>
		new Vue({
			el:"#animated-number-demo",
			data:{
				number:0,
				animatedNumber:0
			},
			watch:{
				number:function(newValue,oldValue){
					var vm=this;
					function animate(time){
						requestAnimationFrame(animate);
						TWEEN.update(time);
					}
					new TWEEN.Tween({ tweeningNumber: oldValue })
					.easing(TWEEN.Easing.Quadratic.Out)
					.to({ tweeningNumber: newValue }, 500)
					.onUpdate(function () {
					  vm.animatedNumber = this.tweeningNumber.toFixed(0)
					}).start()
					animate()
				}
			}
		});
		//当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如css中的color值，通过color.js实现如下案例：
			<script src="https://unpkg.com/tween.js@16.3.4"></script>
			<script src="https://unpkg.com/color-js@1.0.3/color.js"></script>
			<div id='example'>
				<input 
					v-model='colorQuery'
					@keyup.enter='updateColor'
					placeholder='Enter a color'
				/>
				<button @click='updateColor'>Update</button>
				<p>Preview:</p>
				<span :style='{backgroundColor:tweenedCssColor}'></span>
				<p>{{tweenedCssColor}}</p>
			</div>
			var Color=net.brehaut.Color;
			new Vue({
				el:'#example',
				data:{
					colorQuery:'',
					color:{
						red:0,
						green:0,
						blue:0,
						alpha:1
					},
					tweenedColor:{}
				},
				created:function(){
					this.tweenedColor=Object.assign({},this.color);
				},
				watch:{
				     color: function () {
				      function animate (time) {
					requestAnimationFrame(animate)
					TWEEN.update(time)
				      }
				      new TWEEN.Tween(this.tweenedColor)
					.to(this.color, 750)
					.start()
				      animate()
				    }
				  },
				  computed: {
				    tweenedCSSColor: function () {
				      return new Color({
					red: this.tweenedColor.red,
					green: this.tweenedColor.green,
					blue: this.tweenedColor.blue,
					alpha: this.tweenedColor.alpha
				      }).toCSS()
				    }
				  },
				  methods: {
				    updateColor: function () {
				      this.color = new Color(this.colorQuery).toRGB()
				      this.colorQuery = ''
				    }
				  }
			});
		》动态状态转换
			就像Vue的过渡组件一样，数据背后状态转换会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的SVG多边形也可是实现很多难以想象的效果。
			https://jsfiddle.net/chrisvfritz/65gLu2b6/
		》通过组件组织过渡
			管理太多的状态转换会很快的增加Vue实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。
			<script src="https://unpkg.com/tween.js@16.3.4"></script>
			<div id='example'>
				<input v-model.number='firstNumber' type='number' step='20'/> +
				<input v-model.number='secondNumber' type='number' step='20'/> =
				{{result}}
				<p>
				    <animated-integer v-bind:value="firstNumber"></animated-integer> +
				    <animated-integer v-bind:value="secondNumber"></animated-integer> =
				    <animated-integer v-bind:value="result"></animated-integer>
				</p>
			</div>
			Vue.component('animated-integer',{
				template:'<span>{{tweeningValue}}</span>',
				props:{
					value:{
						type:Number,
						require:true
					},
					data:function(){
						return {
							tweeningValue:0
						}
					},
					watch:{
						value:function(newValue,oldValue){
							this.tween(oldValue,newValue);
						}
					},
					mounted:function(){
						this.tween(0,this.value);
					},
					methods:function(){
						tween: function (startValue, endValue) {
						      var vm = this
						      function animate (time) {
							requestAnimationFrame(animate)
							TWEEN.update(time)
						      }
						      new TWEEN.Tween({ tweeningValue: startValue })
							.to({ tweeningValue: endValue }, 500)
							.onUpdate(function () {
							  vm.tweeningValue = this.tweeningValue.toFixed(0)
							}).start()
						      animate()
						 }
					}
				}
			});
			new Vue({
				el:'#example',
				data:{
					firstNumber:20,
					secondNumber:40
				},
				computed:{
					result:function(){
						return this.firstNumber + this.secondNumber;
					}
				}
			});
15.Render函数
	》基础
		Vue推荐使用在大多数情况下使用template来创建html。然而在一些场景中，你真的需要js的完全编程的能力--render函数，它比template更接近编译器。
		<h1>
			<a name='hello-world' href='#hello-world'>Hello world!</a>
		</h1>
		//在html层，定义组件借口
		<anchored-heading :level='1'>Hello world!</anchored-heading>
		//当我们开始写一个通过level prop动态生成heading标签的组件：
		<script type='text/x-template' id='anchored-heading-template'>
			  <div>
			    <h1 v-if="level === 1">
			      <slot></slot>
			    </h1>
			    <h2 v-if="level === 2">
			      <slot></slot>
			    </h2>
			    <h3 v-if="level === 3">
			      <slot></slot>
			    </h3>
			    <h4 v-if="level === 4">
			      <slot></slot>
			    </h4>
			    <h5 v-if="level === 5">
			      <slot></slot>
			    </h5>
			    <h6 v-if="level === 6">
			      <slot></slot>
			    </h6>
			  </div>
		</script>
		Vue.component('anchored-heading',{
			template:'#anchored-heading-template',
			props:{
				level:{
					type:Number,
					required:true
				}
			}
		});
		//在这种场景中使用template并不是最好的选择：
			》代码冗长,为了在不同级别的标题中插入锚点元素，需要重复地使用<slot></slot>
			》由于组件必须有根节点，标题和锚点元素被包裹在一个无用的div中
		//使用render函数重写上面的案例
			Vue.component('anchored-heading',{
				render:function(createElement){
					return createElement('h'+this.level,//Tag 标签名
						this.$slots.default//子组件 即hX标签体内容
					)
				},
				props:{
					level:{
						type:Number,
						required:true
					}
				}
			});
			//当不使用slot属性向组件中传递内容时，如anchored-heading中的Hello world，这些子元素被存储在组件实例中$slots.default中。
		》createElement参数
			如何在createElement函数中生成模板，createElement接受的参数如下：
			//该函数 return { VNode }
			createElement(
				//第一个参数 必要参数
				//{String | Object | Function}
				//一个html标签名字符串 或 组件选项对象 或一个返回值类型为String或Object的函数
				'div',
				//第二个参数 可选参数
				//一个包含模版相关属性的数据对象 { Object }--可以在template中使用这些属性
				{
					//注意：正如在模版语法中，v-bind:class和v-bind:style,会被特别对待一样，
					//在VNode数据对象中 下列属性名是级别最高的字段
					//和v-bind:class一样的API
					'class':{
						foo:true,
						bar:false
					},
					//和v-bind:style一样的API
					style:{
						color:'red',
						fontSize:'14px'
					},
					//正常的HTML特性
					attrs:{
						id:'foo'
					},
					//组件props
					props:{
						myProp:'bar'
					},
					//DOM 属性
					domProps:{
						innerHTML:'baz'
					},
					//事件监听器基于on 不在支持 @keyup.enter修饰器  需要手动匹配keyCode
					on:{
						click:this.clickHandler
					},
					//仅对于组件 用于监听原生事件，而不是组件内部使用 vm.$emit触发的事件
					nativeOn:{
						click:this.nativeClickHandler
					},
					//自定义指令，注意：不能对绑定的旧值设值 Vue会持续追踪
					directives:[
						{
							name:'my-custom-directive',
							value:'2',
							expression:'1 + 1',
							arg:'foo',
							modifiers:{
								bar:true
							}
						}
					],
					//Scoped slots {name:props=>VNode | Array<VNode>}
					scopedSlots:{
						default:props=> h('span',props.text)
					},
					//如果组件是其他组件的子组件，需要为slot指定名称
					slot:'name-of-slot',
					key:'myKey',
					ref:'myRef'
				}，
				//第三个参数 可选参数--子节点(VNodes)，可以是一个字符串 或 一个数组
				[
					createElement('h1','hello world'),
					createElement(MyComponent,{
						props:{
							someProp:'foo'
						}
					}),
					'bar'
				]
			);
		》案例
			var getChildrenTextContent=function(children){
				return children.map(function(node){
					return node.children?getChildrenTextContent(node.children):node.text;
				}).join('');
			}
			Vue.component('anchored-heading',{
				render:function(createElement){
					var headingId = getChildrenTextContent(this.$slots.default)
						      .toLowerCase()
						      .replace(/\W+/g, '-')
						      .replace(/(^\-|\-$)/g, '');
					return createElement(
						'h'+this.level,
						[
							createElement('a',{
								attrs:{
									name:headingId,
									href:'#'+headingId
								}
							},this.$slots.default)
						]
					),
					props:{
						level:{
							type:Number,
							required:true
						}
					}
				}
			});
		》约束
			VNodes必须唯一
			组件树中的所有VNodes必须是唯一的。这意味着，下面的render function是无效的：
			render:function(createElement){
				var myVNode=createElement('p','hi');
				return createElement('div',[
					myVNode,myVNode//重复的VNodes  -- 错误
				]);
			}
			//如果需要重复很多次的元素或组件，你可以使用工厂函数来实现
			render:function(createElement){
				return createElement('div',
					Array.apply(null,{length:20}).map(function(){
						return createElement('p','hi');
					});
				);
			}
		》使用js代替模版功能
			》v-if 与 v-for--render函数没有提供专用的API来实现这个两指令的功能
				<ul v-if='items.length'>
					<li v-for='item in items'>{{item.name}}</li>
				</ul>
				<p v-else>No items found</p>
				//在render函数中被 if/else 与 map重写
				render:function(createElement){
					if(this.items.length){
						return createElement('ul',this.items.map(function(item){
							return createElement('li',item.name);
						}));
					}else{
						return createElement('p','No items found')
					}
				}
			》v-model
				render函数中没有与v-model相应的api--必须自己实现相应的逻辑：
				render:function(createElement){
					var self=this;
					return createElement('input',{
						domProps:{
							value:self.value
						},
						on:{
							input:function(event){
								self.value=event.target.value;
							}
						}
					});
				}
				//虽然这样麻烦，但是相对于v-model来说，你可以更灵活地控制
			》事件 与 按键修饰符
				对于.capture和.once事件修饰符，vue提供了相应的前缀可以用于on
				.capture ！//捕获
				.once ~    //事件仅执行一次
				.capture.once or .once.capture ~!
				案例：
				on:{
					'!click':this.doThisCapturingMode
				}
				//其他修饰符，使用事件方法
				.stop		event.stopPropagation()
				.prevent	event.preventDefault()
				.self		if (event.target !== event.currentTarget) return//触发事件的元素不是事件绑定的元素
				Keys:
					.enter, .13	if (event.keyCode !== 13) return 
				Modifiers Keys:
					.ctrl, .alt, .shift, .meta	if (!event.ctrlKey) return (change ctrlKey to altKey, shiftKey, or metaKey, respectively)
			》slots
				可以从this.$slots获取VNode列表的静态内容
				render：function(createElement){
					//<div><slot></slot></div>
					return createElement('div',this.$slot.default);
				}
				render:function(createElement){
					//<div><slot :text='msg'></slot></div>
					return createElement('div',[
						this.$scopedSlots.default({
							text:this.msg
						})
					]);
				}
				render (createElement){
					return createElement('div',[
						createElement('child',{
							scopedSlots:{
								default:function(props){
									return createElement('span',props.text);
								}
							}
						});
					]);
				}
		》JSX
			<anchored-heading :level='1'>
				<span>Hello</span>world!
			</anchored-heading>
			createElement(
				'anchored-heading',{
					props:{
						level:1
					}
				},[
					createElement('span','Hello'),
					'world'
				]
			);
			//上面写法太繁琐，这就引入了babel plugin插件，用于在vue中使用jsx语法的原因。
			import AnchoredHeading from './AnchoredHeading.vue'
			new Vue({
			  el: '#demo',
			  render (h) {
			    return (
			      <AnchoredHeading level={1}>
				<span>Hello</span> world!
			      </AnchoredHeading>
			    )
			  }
			})
			//将h作为createElement的别名是vue系统中一个通用的惯例，实际上也是jsx所要求的。如果作用域中h失去作用，在应用中会触发报错。
			//安装
			npm install babel-plugin-syntax-jsx babel-plugin-transform-vue-jsx babel-helper-vue-jsx-merge-props babel-preset-es2015 --save-dev
			//.babelrc
			{
			  "presets": ["es2015"],
			  "plugins": ["transform-vue-jsx"]
			}
			//案例
				<div id='foo'>{this.text}</div>
				h('div',{
					attrs:{
						id:'foo'
					}
				},[this.text]);
				Vue.component('jsx-example',{
					render(h){
						return <div id='foo'>bar</div>
					}
				});
			//h的自动注入
				Vue.component('jsx-example', {
				  render () { // h能自动注入
				    return <div id="foo">bar</div>
				  },
				  myMethod: function () { // h不能自动注入
				    return <div id="foo">bar</div>
				  },
				  someOtherMethod: () => { // h不能自动注入
				    return <div id="foo">bar</div>
				  }
				})

				@Component
				class App extends Vue {
				  get computed () { // h能自动注入
				    return <div id="foo">bar</div>
				  }
				}
			//与React jsx的不同
				render (h) {
				  return h('div', {
				    props: {
				      msg: 'hi'
				    },
				    attrs: {
				      id: 'foo'
				    },
				    domProps: {
				      innerHTML: 'bar'
				    },
				    on: {
				      click: this.clickHandler
				    },
				    nativeOn: {
				      click: this.nativeClickHandler
				    },
				    class: {
				      foo: true,
				      bar: false
				    },
				    style: {
				      color: 'red',
				      fontSize: '14px'
				    },
				    key: 'key',
				    ref: 'ref',
				    refInFor: true,
				    slot: 'slot'
				  })
				}
				//jsx
				render (h) {
				  return (
				    <div
				      id="foo"
				      domPropsInnerHTML="bar"
				      onClick={this.clickHandler}
				      nativeOnClick={this.nativeClickHandler}
				      class={{ foo: true, bar: false }}
				      style={{ color: 'red', fontSize: '14px' }}
				      key="key"
				      ref="ref"
				      refInFor
				      slot="slot">
				    </div>
				  )
				}
			//不需要注册组件
				import Todo from './Todo.js'
				export default {
				  render (h) {
				    return <Todo/> // 不需要用components选项注册组件
				  }
				}
			//jsx的传播
			const data = {
			  class: ['b', 'c']
			}
			const vnode = <div class="a" {...data}/>
				//合并
				{ class: ['a', 'b', 'c'] }
			//vue的指令
				const directives = [
				  { name: 'my-dir', value: 123, modifiers: { abc: true } }
				]
				return <div {...{ directives }}/>
		》函数化组件
			标记组件为functional，这意味着它是无状态(没有data)，无实例(没有this上下文);
			Vue.component('my-component'，{
				functional:true,
				//为了弥补缺失的实例 提供了第二个参数作为上下文
				render:function(createElement,context){
					
				},
				props:{//可选
				
				}
			});
			//注意：在2.3以前，如果一个函数式组件想要接受props，则props选项是必须的，在此之后
			props选项可以省略，所有组件上的属性都会被自动解析为props。
			》组件需要的数据通过上下文传递
				》props 提供props对象
				》children VNode子节点数组
				》slots slots对象
				》data 传递给组件的data对象
				》parent 对父组件的引用
				》listeners 一个包含了组件上所注册的v-on监听器对象，这只是一个指向data.on的别名
				》injections 如果使用inject选项 则该对象包含了应当被注入的属性
				//在添加functional:true之后，锚点标题组件的render函数之间更简单 context参数。
				//this.$slots.default 更新为context.children 
				//this.level 更新为context.props.level
				因为函数化组件只是一个函数，所以渲染开销也低很多。在作为包装组件时，它们也同样非常有用。
				如：以下情况：
					》程序化在多个组件中选择一个
					》在将children props data传递给子组件之前操作它们
					var EmptyList = { /* ... */ }
					var TableList = { /* ... */ }
					var OrderedList = { /* ... */ }
					var UnorderedList = { /* ... */ }
					Vue.component('smart-list', {
					  functional: true,
					  render: function (createElement, context) {
					    function appropriateListComponent () {
					      var items = context.props.items
					      if (items.length === 0)           return EmptyList
					      if (typeof items[0] === 'object') return TableList
					      if (context.props.isOrdered)      return OrderedList
					      return UnorderedList
					    }
					    return createElement(
					      appropriateListComponent(),
					      context.data,
					      context.children
					    )
					  },
					  props: {
					    items: {
					      type: Array,
					      required: true
					    },
					    isOrdered: Boolean
					  }
					})
			》slots()和children对比
				<my-functional-component>
					<p slot='foo'>
						first
					</p>
					<p>second</p>
				</my-functional-component>
				//对于这个组件 children会给两个段落标签，而slots().default只会传递第二个匿名段落标签，slots().foo会传递第一个具名段落标签。
				同时拥有children和slots(),因此可以选择让组件通过slot()系统分发或简单的通过children接收，让其他组件去处理。
		》模板编译
			Vue的模板实际是编译成了render函数。通过Vue.compile编译vue模板
16.自定义指令
	除了默认设置的核心指令，Vue也允许注册自定义指令。注意。在vue2.0中，代码复用的主要形式和抽象是组件--然而有的情况，你仍然要对纯DOM
	元素进行底层操作，这时候就会用到自定义指令。
	//当页面加载时，元素将获取焦点。即你访问后还没点击任何内容，input就获得了焦点
		//注册一个全局自定义指令 v-focus
		Vue.directive('focus',{
			//inserted hook当绑定元素插入到DOM中
			inserted:function(el){
				el.focus();//聚焦元素
			}
		});
		//也可以注册局部指令，组件中接受一个directives的选项
		directives:{
			focus:{
				//指令的定义
			}
		}
		//然后在模板中任何元素上使用v-focus属性
		<input v-focus/>
		》钩子函数--可选
			bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作
			inserted：被绑定元素插入父节点时调用--父节点存在即可调用，不必存在于document中
			update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
			componentUpdated:被绑定元素所在模板完成一次更新周期时调用
			unbind:只调用一次，指令与元素解绑时调用
		》钩子函数参数
			》el 指令所绑定的元素，可以用来直接操作DOM
			》binding 一个对象，其属性：
				{
					name:指令名，不包括v-前缀
					value:指令的绑定值，如v-my-directive='1+1'，其值是2
					oldValue：指令绑定的前一个值，仅在update componentUpdated钩子中可用，无论值是否改变都可用
					expression：绑定值的字符串形式，如v-my-directive='1+1'，其值就是'1+1'
					arg:传给指令的参数 如：v-my-directive:foo 其值就是'foo',
					modifiers:一个包含修饰符的对象 如：v-my-directive.foo.bar 修饰符对象modifiers的值是{foo:true,bar:true}
				}
			》vnode Vue编译生成的虚拟节点
			》oldVnode 上一个虚拟节点 仅在update componentUpdated钩子中可用
			注意：除了el之外，其他参数都应该是只读，尽量不要修改它们。如果需要在钩子之间共享数据，建议通过元素的dataset来进行
			//案例
				<div id='hook' v-demo:hello.a.b='message'></div>
				Vue.directive('demo',{
					bind:function(el,binding,vnode){
						var s=JSON.stringify;
						el.innerHTML=
						      'name: '       + s(binding.name) + '<br>' +
						      'value: '      + s(binding.value) + '<br>' +
						      'expression: ' + s(binding.expression) + '<br>' +
						      'argument: '   + s(binding.arg) + '<br>' +
						      'modifiers: '  + s(binding.modifiers) + '<br>' +
						      'vnode keys: ' + Object.keys(vnode).join(', ')
					}
				});
				new Vue({
					el:'#hook',
					data:{
						message:'hello!'
					}
				});
			》函数简写
				大多数情况下，可能想在bind和update钩子上做重复动作，并且不想关心其它的钩子函数。
				Vue.directive('color-swatch',function(el,binding){
					el.style.backgroundColor=binding.value
				})
			》对象字面量
				如果指令需要多个值，可以传入一个js对象字面量。指令函数能够接受所有合法类型的js表达式
				<div v-demo='{color:"white",text:"hello"}'></div>
				Vue.directive('demo',function(el,binding){
					binding.value.color//white
					binding.value.text//hello
				});
17.混合
	》基础
		混合是一种灵活的分布式复用Vue组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。
		//定义一个混合对象
		var myMixin={
			created:function(){
				this.hello();
			},
			methods:{
				hello:function(){
					console.log('hello from mixin!');
				}
			}
		}
		//定义一个使用混合对象的组件
		var Component=Vue.extend({
			mixins:[myMixin]
		});
		var component=new Component();//hello from mixin
		》选项合并
			当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。如：同名钩子函数将混合为一个数组，因此都将被调用。
			另外，混合对象的钩子将在组件自身钩子之前调用。
			var mixin={
				created:function(){
					console.log('混合对象的钩子被调用');
				}
			}
			new Vue({
				mixins:[mixin],
				created:function(){
					console.log('组件钩子被调用');
				}
			});
			// -> "混合对象的钩子被调用"
			// -> "组件钩子被调用"
			》值为对象的选项，如：methods components directives，将被混合为同一个对象，两个对象键名冲突时，取组件对象的键值对。
				var mixin={
					methods:{
						foo:function(){
							console.log('foo');
						},
						conflicting:function(){
							console.log('from mixin');
						}
					}
				}
				var vm=new Vue({
					mixins:[mixin],
					methods:{
						bar:function(){
							console.log('bar');
						},
						conflicting:function(){
							console.log('from self');
						}
					}
				});
				vm.foo() // -> "foo"
				vm.bar() // -> "bar"
				vm.conflicting() // -> "from self"
				//注意：Vue.extend()也使用同样的策略进行合并
		》全局混合
			也可以全局注册混合对象，注意：一旦使用全局混合对象，将会影响到所有之后创建的Vue实例，使用恰当时，可以为自定义对象注入处理逻辑。
			//为自定义的选项 'myOption'注入一个处理器
			Vue.mixin({
				created:function(){
					var myOption=this.$options.myOption;
					if(myOption){
						console.log(myOption);
					}
				}
			});
			new Vue({
				myOption:'hello!'
			});
			//'hello!'
			//谨慎使用全局混合对象，因为会影响到每个单独创建的Vue实例(包括第三方模板)，大多数情况下，**只应当应用于自定义选项**就像上面示例一样。也可以将其用作**Plugins**以避免产生重复应用。
		》自定义选项混合策略
			自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑混合，可以向
			Vue.config.optionMergeStrategies添加一个函数：
				Vue.config.optionMergeStrategies.myOption=function(toVal,fromVal){
					//return mergedVal
				}
			对于大多数对象选项，可以使用methods的合并策略：
			var strategies=Vue.config.optionMergeStrategies;
			strategies.myOption=strategies.methods

			const merge = Vue.config.optionMergeStrategies.computed
			Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
			  if (!toVal) return fromVal
			  if (!fromVal) return toVal
			  return {
			    getters: merge(toVal.getters, fromVal.getters),
			    state: merge(toVal.state, fromVal.state),
			    actions: merge(toVal.actions, fromVal.actions)
			  }
			}
18.插件
	》开发插件
		插件通常会为Vue添加全局功能，插件的范围没有限制--一般有下面几种：
		》添加全局方法或属性 如vue-element
		》添加全局资源 ：指令 过滤器 过渡等 如vue-touch
		》通过全局mixin方法添加一些组件选项 如：vuex
		》添加Vue实例方法，通过把它们添加到Vue.prototype上实现
		》一个库，提供自己的API，同时提供上面提到的一个或多个功能 如vue-router
		Vue的插件应当有一个公开的方法install，这个方法的第一个参数是Vue构造器，第二个参数是一个可选的选项对象。
		MyPlugin.install=function(Vue,options){
			//添加全局方法或属性
			Vue.myGlobalMethod=function(){
				//逻辑...
			}
			//添加全局资源
			Vue.directive('my-directive',{
				bind(el,binding,vnode,oldVnode){
					//...
				}
			});
			//注入组件
			Vue.mixin({
				created:function(){
					//逻辑
				}
			});
			//添加实例方法
			Vue.prototype.$myMethod=function(options){
				//逻辑
			}
		}
	》使用插件
		//通过全局方法Vue.use()使用插件
		Vue.use(MyPlugin);
		//也可以传入一个选项对象
		Vue.use(MyPlugin,{someOption:true});
		Vue.use会自动阻止注册相同插件多次，届时只会注册一次该插件;
		一些插件 如Vue-router如果Vue是全局变量则自动调用Vue.use()。不过在模块环境中应当始终显示调用Vue.use():
			// 通过 Browserify 或 Webpack 使用 CommonJS 兼容模块
			var Vue = require('vue')
			var VueRouter = require('vue-router')
			// 不要忘了调用此方法
			Vue.use(VueRouter)
19.单文件组件
	在很多Vue项目中，我们使用Vue.component来定义全局组件，紧接着用new Vue({el:'#container'});在每个页面指定一个容器元素。
	这种方式在很多中小规模的项目中运作的很好，在这些项目里js只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完
	全由js驱动的时候，下面这些缺点将变得很明显：
	》全局定义Global definitions 强制要求每个component中的命名不得重复
	》字符串模板 String templates缺乏语法高亮，在html有多行的时候 需要用到丑陋的\
	》不支持css 意味着当html和js组件化时 css明显被遗漏
	》没有构建步骤 限制只能使用html 和 ES5 而不能使用预处理器
	文件扩展名.vue的单文件组件为以上所有问题提供了解决方法，并且可以使用webpack brwserify等构建工具
		//Hello.vue
		<template>
			//html标签
		</template>
		<script>
			export default {
				//js代码
			}
		</script>
		<style scoped>
			//css
		</style>
		//webpack 需要用vue-loader来处理.vue单文件
			//vue单文件
			<style{{#sass}} lang="scss"{{/sass}}>
				//scss语法
			</style>
			//处理scss
			{
				test: /\.vue$/,
				loader: 'vue-loader',
				options: {
				  loaders: {
					{{#sass}}
						'scss': 'vue-style-loader!css-loader!sass-loader',
						'sass': 'vue-style-loader!css-loader!sass-loader?indentedSyntax'
					{{/sass}}
				  }
				}
			}
		》vue-loader 文档
			》vue-loader是什么
				vue-loader是一个webpack的loader 可以将.vue文件编写的Vue组件转换成js模块。
				vue-loader提供了很多特性：
					》es2015默认支持
					》允许vue组件的组成部分使用其他webpack loaders 如：<style>使用sass <template>使用jade
					》.vue文件中允许自定义节点，然后使用自定义的loader处理它们
					》把<style>和<template>中的静态资源当做模板来对待，并使用webpack loaders进行处理
					》对每个组件模拟出css作用域
					》支持开发期组件的热重载
			》Vue组件细则
				.vue文件是一个自定义的文件类型，用类html语法描述一个Vue组件。每个.vue文件包含了三种类型的顶级语言块
				<template>、<script>、<style>，还允许添加可选的自定义块：
				<template>//html块
					/**
					<template>语言块 默认语言html
					每个.vue文件**最多**包含一个<template>块
					内容将被提取为字符串，将编译并用作vue组件的template选项
					*/
					<div class="example">{{ msg }}</div>
				</template>
				<script>//js块
					/**
					默认语言：js 在检测到babel-loader或buble-loader配置时自动支持ES2015
					每个.vue文件**最多**包含一个<script>块
					该脚本在类commonjs环境中执行就像通过webpack打包的正常js模块，这意味着你可以require()其他依赖。
						在ES2015支持下，也可以使用import 和 export语法
					脚本**必须**导出Vue.js组件对象，也可以导出由Vue.extend()创建的扩展对象，但是普通对象时更好的选择
					*/
					export default {
					  data () {
					    return {
					      msg: 'Hello world!'
					    }
					  }
					}
				</script>
				<style>//css块
					/**
					默认语言：css
					一个.vue文件可以包含多个<style>标签
					<style>标签可以有scoped或module属性以帮助你将样式封装到当前组件。具有不同
						封装模式的多个<style>标签可以在同一个组件中混合使用。
					默认情况下，将会使用style-loader提取内容，并通过<style>标签动态加入文档的<head>中，也可以配置
						webpack将所有styles提取到单个css文件中
					*/
					.example {
					  color: red;
					}
				</style>
				<custom1>//自定义块
					/**
					只在vue-loader 10.2+中支持
					可以在.vue文件中添加额外的自定义块来实现项目的特定需求。如<docs>块，vue-loader将会使用标签名来
					查找对应的webpack loaders来应用在对应的块上，webpack loaders需要在vue-loader的选项loaders中指定。
					*/
					This could be e.g. documentation for the component.
				</custom1>
				//vue-loader会解析文件，提取每个语言块，如有必要会通过其他loader处理，最后将他们组装成一个CommonJs模块，module.exports出一个vue.js组件对象。
				//vue-loader支持使用非默认语言，如css预处理器，预编译html模板语言，通过设置语言块的lang属性。
					<style lang='sass'>
						//sass语法
					</style>
				》src导入
					如果你喜欢分隔你的.vue文件到多个文件中，可以通过src属性导入外部文件
					<template src="./template.html"></template>
					<style src="./style.css"></style>
					<script src="./script.js"></script>
					//需要注意的是src导入遵循和require()一样的规则，这意味着你相对路径需要以./开始，你还可以从npm
					//包中直接导入资源
						<style src="todomvc-app-css/index.css">
					//在自定义块上同样支持src导入
						<unit-test src='./unit-test.js'></unit-test>
				》语法高亮
					在很多编辑器中都支持语法高亮，如果vue组件中没有使用任何预处理器，你可以把
					.vue文件当作html对待
				》注释
					在语言块中使用该语言块的对应的注释语法，
					顶层注释使用html注释语法<!-- 注释 -->
			》创建项目
				使用vue-cli
				推荐使用脚手架工具vue-cli来创建一个使用vue-loader的项目
				npm install -g vue-cli
				vue init webpack-simple hello-vue
				cd hello-vue
				npm install
				npm run dev # ready to go!
			》ES2015
				当项目中配置了babel-loader或buble-loader，vue-loader会使用它们处理所有.vue文件中的
				<script>部分，允许我们在Vue组件中使用Es2015。
				下面是导入其他Vue组件的典型写法
				<script>
					import ComponentA from './ComponentA.vue';
					export default {
						components:{
							ComponentA
						}
					}
				</script>
				//在Templates中使用Es2015
				.vue中<template>会编译为js渲染函数，然后通过自定义构建的buble去支持Es2015，这允许你使用属性的简洁表示法和属性名表达式：
				<div :class='[{active:active},isButton?prefix+"-button":null]'></div>
				简写：
				<div :class="{active,[`${prefix}-button`]:isButton}"></div>
				可以在v-for或scoped slots中使用解构赋值：
				<li v-for="{ id, text } in items">
				  {{ id }} {{ text }}
				</li>
				<my-component>
				  <template scope="{ id, text }">
				    <span>{{ id }} {{ text }}</span>
				  </template>
				</my-component>
				//转换普通的.js文件
				由于vue-loader只处理.vue文件，你需要告诉webpack如何使用babel-loader或buble-loader处理普通
				.js文件，由于webpack中配置了babel-loader或buble-loader。脚手架工具vue-cli已经为你做了这些。
				//使用.babelrc配置babel
					babel-loader遵守.babelrc，因此这是配置babel presets和插件的推荐方法
			》css作用域
				当<style>标签有scoped属性时，它的css只作用于当前组件中的元素。这类似于Shadow DOM中的样式封装。
				它有一些注意事项，但是不需要任何polyfills。它通过Postcss来实现以下转换：
				<style scoped>
					.example{
						color:red
					}
				</style>
				<template>
					<div class='example'>hi</div>
				</template>
				//转换结果
				<style>
					.example[data-v-f3f3eg9] {
					  color: red;
					}
				</style>
				<template>
					 <div class="example" data-v-f3f3eg9>hi</div>
				</template>
				//注意：
					》你可以在一个组件中同时使用scoped和non-scoped styles
						<style>
							//全局样式
						</style>
						<style scoped>
							//当前组件样式
						</style>
					》子组件的根节点将同时受到父组件和子组件作用域的css的影响
					》Partials不受作用域样式的影响
					》css作用域不能代替classes，考虑到浏览器渲染各种css的选择器方式，使用scoped时，p{color:red}在作用域中会慢很多倍(即与属性选择器组合时)。如果你使用classes或者ids代替
					  如：.example{color:red}这样几乎没有性能影响
					》在递归组件中小心使用后代选择器，对于带有选择器.a .b的css规则，如果元素.a包含递归子组件，所有的子组件中的.b会被匹配。
			》css模块
				css模块是一个用于模块化和组合css的流行系统。vue-loader提供了与css模块的一流集成，可以作为模拟css作用域的替代方案。
				》使用
					在你的<style>上添加module属性：
					<style module>
						.red{
							color:red;
						}
						.bold{
							font-weight:bold;
						}
					</style>
					这将为css-loader打开css的模块模式，生成的css对象将为组件注入一个名叫$style的计算属性，你可以在你的模块中使用动态class绑定：
					<template>
						<p :class='$style.red'>
							This should be red;
						</p>
					</template>
					由于它是一个计算属性，它也适用于:class的object/array语法：
					<template>
						<div>
							<p :class="{[$style.red]:isRed}">
								Am I red?
							</p>
							<p :class="[$style.red,$style.bold]">
								Red and bold
							</p>
						</div>
					</template>
					你也可以在js中访问它：
					<script>
						export default{
							created(){
								console.log(this.$style.red);
							}
						}
					</script>
				》自定义注入名称
					在.vue中你可以定义不止一个<style>为了避免被覆盖，你可以通过设置module属性来为它们定义注入后计算属性的名称：
					<style module='a'></style>
				》配置css-loader Query
					css模块处理是通过css-loader，默认query如下：
					{
						modules:true,
						importLoaders:true,
						localIdentName:'[hash:base64]'
					}
					//你可以使用vue-loader的cssModules选项为css-loader添加query配置：
					// webpack 1
					vue: {
					  cssModules: {
					    // overwrite local ident name
					    localIdentName: '[path][name]---[local]---[hash:base64:5]',
					    // enable camelCase
					    camelCase: true
					  }
					}
					// webpack 2
					module: {
					  rules: [
					    {
					      test: '\.vue$',
					      loader: 'vue-loader',
					      options: {
						cssModules: {
						  localIdentName: '[path][name]---[local]---[hash:base64:5]',
						  camelCase: true
						}
					      }
					    }
					  ]
					}
			》PostCss
				由于vue-loader处理的css输出，都是通过PostCSS进行作用域重写，你还可以为Postcss添加自定义插件,
				如：autoprefixer 或 CSSNext
				》使用配置文件
					vue-loader从11.0版本开始支持通过postcss-loader自动加载同一个配置文件：
					》postcss.config.js
					》.postcssrc
					》package.json中的postcss
					使用配置文件允许你在由postcss-loader处理的普通css文件和*.vue文件中的css之间共享相同的配置，--推荐做法
				》内联选项
					可以使用vue-loader的postcss选项来为.vue文件指定配置
					// webpack.config.js
					module.exports = {
					  // other configs...
					  vue: {
					    // use custom postcss plugins
					    postcss: [require('postcss-cssnext')()]
					  }
					}
					// webpack.config.js
					module.exports = {
					  // other options...
					  module: {
					    // module.rules is the same as module.loaders in 1.x
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						// vue-loader options goes here
						options: {
						  // ...
						  postcss: [require('postcss-cssnext')()]
						}
					      }
					    ]
					  }
					}
					//除了插件数组之外，postcss配置选项也接受：
						》返回插件数组的函数
						》要传递给Postcss处理器的包含options对像，当使用postcss项目依赖自定义
						  parser/stringifiers时，这很有用：
						  postcss: {
							  plugins: [...], // list of plugins
							  options: {
							    parser: sugarss // use sugarss parser
							  }
						  }
			》热重载
				热重载不是当你修改文件的时候简单重新加载页面，启用热重载后，当你修改.vue文件时，所有该组件的实例会被替换，
				并且不需要刷新页面。它甚至保持应用程序和被替换组件的当前状态。你调整模版或修改样式时，这极大的提高了开发
				体验。
				当使用脚手架工具vue-cli时，热重载时开箱即用的。
			》使用预处理器
				在webpack中，所有的预处理器需要匹配对应的loader。vue-loader允许你使用其他webpack loader处理vue组件的某一部分。
				它会根据lang属性自动推断出要使用的loaders。
				》css
					如：使用Sass编译我们的<style>语言块：
					npm install sass-loader node-sass --save-dev
					<style lang="sass">
					  /* write sass here */
					</style>
					在内部<style>标签中的内容将会先由sass-loader进行处理，然后再传递进行下一步处理。
					》sass-loader警告
						与名称相反，sass-loader默认解析scss语法，如果你想要使用语法，你需要配置vue-loader的选项：
						{
						  test: /\.vue$/,
						  loader: 'vue-loader',
						  options: {
						    loaders: {
						      scss: 'vue-style-loader!css-loader!sass-loader', // <style lang="scss">
						      sass: 'vue-style-loader!css-loader!sass-loader?indentedSyntax' // <style lang="sass">
						    }
						  }
						}
				》js
					vue组件中的所有js默认使用babel-loader处理，你也可以改变处理方式：
					npm install coffee-loader --save-dev
					<script lang="coffee">
					  # Write coffeescript!
					</script>
				》模版
					模版的处理方式略有不同，因为大多数webpack的模版处理器如pug-loader会返回模版处理函数，而不是编译的html字符串，
					我们使用原始的pug替代pug-loader：
					npm install pug --save-dev
					<template lang="pug">
					div
					  h1 Hello world!
					</template>
					//注意：如果你使用 vue-loader@<8.2.0， 你还需要安装 template-html-loader。
				》行内Loader Requests
					可以在lang属性中使用 webpack loader requests：
					<style lang="sass?outputStyle=expanded">
					  /* use sass here with expanded output */
					</style>
					//但是这使你的Vue组件只适用于webpack，不能与browserify and vueify一同使用。如果你打算将你的vue组件作为可重复
					//使用的第三方组件，请避免使用这个语法
			》资源路径处理
				默认情况下，vue-loader使用css-loader和vue模板编译器自动处理你的样式和模板文件。
				在编译过程中，所有的资源路径如：<img src='...'> background:url(...)和 @import
				会作为模块依赖。
				如：url(./image.png)会被转换为require('./image.png'),
				<img src="../image.png">
				会被编译为：
				createElement('img', { attrs: { src: require('../image.png') }})
				因为.png不是一个js文件，你需要配置webpack使用file-loader或url-loader去处理他们。
				vue-cli脚手器工具已经为你配置好了。
				使用它们的好处：
					》file-loader可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名
					  以获得更好的缓存。此外这意味着你可以就近管理你的图片文件，可以使用相对路径
					  而不用担心部署时URL问题。使用正确的配置，webpack将会在打包输出中自动重写文件路径
					  为正确的URL。
					》url-loader允许你有条件将文件转换为内联的base-64URL(当文件小于给定的阀值)，这会减少小文件
					  的http请求。如果文件大于该阀值，会自动交给file-loader处理。
			》进阶配置
				Loader进阶配置：
					》对语言应用自定义loader string 而不是让vue-loader去推断
					》覆盖默认语言的内置loader配置
					》使用自定义loader预处理或后处理特定语言块
					为此，需指定vue-loader的loaders选项：
					注意preLoaders和postLoaders只在版本>=10.3支持
					//webpack2.x
					module.exports={
						module:{
							rules:[
								{
									test:/\.vue$/,
									loader:'vue-loader',
									options:{
										loaders:{//'loaders'覆盖默认loaders 以下配置会导致所有<script>标签'lang'属性失效
											js:'coffee-loader'
										}，
										preLoaders:{//preLoaders 会在默认loaders之前加载 可以用来预处理语言块
											js:'/path/to/custom/loader'
										}，
										postLoaders:{//`postLoaders` 会在默认 loaders 之后加载. 
											//对于 `html`, 默认 loader 返回会编译为 JavaScript 渲染函数
											html:'babel-loader'
											//对于 `css`, 由`vue-style-loader` 返回的结果通常不太有用。使用 postcss 插件将会是更好的选择。
										}，
										// `excludedPreLoaders` 应是正则表达式
										excludedPreLoaders: /(eslint-loader)/
									}
								}
							]
						}
					}
					//webpack 1.x
					// webpack.config.js
					module.exports = {
					  // other options...
					  module: {
					    loaders: [
					      {
						test: /\.vue$/,
						loader: 'vue'
					      }
					    ]
					  },
					  // vue-loader configurations
					  vue: {
					    loaders: {
					      // same configuration rules as above
					    }
					  }
					}
			》提取css文件
				提取css到单个文件：npm install extract-text-webpack-plugin --save-dev
				》简单的方法
					需要vue-loader>12.0 webpack >2.0
					//webpack.config.js
					var ExtractTextPlugin = require("extract-text-webpack-plugin");
					module.exports = {
					  // other options...
					  module: {
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						options: {
						  extractCSS: true
						}
					      }
					    ]
					  },
					  plugins: [
					    new ExtractTextPlugin("style.css")
					  ]
					}
					//上述内容将自动处理*.vue文件内的<style>提取，并与大多数预处理一样开箱即用。
					//注意这只是提取.vue文件，但在js中导入的css仍然需要单独配置
				》手动配置
					将所有vue组件中的所有已处理的css提取为单个css文件配置实例
					//webpack 2.x
					// webpack.config.js
					var ExtractTextPlugin = require("extract-text-webpack-plugin")
					module.exports = {
					  // other options...
					  module: {
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						options: {
						  loaders: {
						    css: ExtractTextPlugin.extract({
						      use: 'css-loader',
						      fallback: 'vue-style-loader' // <- 这是vue-loader的依赖，所以如果使用npm3，则不需要显式安装
						    })
						  }
						}
					      }
					    ]
					  },
					  plugins: [
					    new ExtractTextPlugin("style.css")
					  ]
					}
					//webpack 1.x
					// webpack.config.js
					var ExtractTextPlugin = require("extract-text-webpack-plugin")
					module.exports = {
					  // other options...
					  module: {
					    loaders: [
					      {
						test: /\.vue$/,
						loader: 'vue'
					      },
					    ]
					  },
					  vue: {
					    loaders: {
					      css: ExtractTextPlugin.extract("css"),
					      // 你还可以引入 <style lang="less"> 或其它语言
					      less: ExtractTextPlugin.extract("css!less")
					    }
					  },
					  plugins: [
					    new ExtractTextPlugin("style.css")
					  ]
					}
			》自定义块 -- 在大于10.2中支持
				在.vue文件中，你可以自定义语言块，自定义块的内容将由vue-loader的options中的loader对象中指定的loader处理，然后被组件
				模块依赖。类似Loader进阶配置中的配置，但使用的是**标签名**匹配，而不是lang属性。
				如果找到一个自定义块的matching loader 该自定义块将被处理，否则自定义块将被忽略。另外如果找到的loader返回一个函数，该
				函数将以*.vue文件的组件作为参数来调用。
				案例：//提取自定义块<docs>的内容到单个docs文件中的例子
				//component.vue
				<docs>
					This is an example component.
				</docs>
				<template>
					<h2 class="red">{{msg}}</h2>
				</template>
				<script>
					export default {
					  data () {
					    return {
					      msg: 'Hello from Component A!'
					    }
					  }
					}
				</script>
				<style>
					comp-a h2 {
					  color: #f00;
					}
				</style>
				//webpack.config.js
				// Webpack 2.x
				var ExtractTextPlugin = require("extract-text-webpack-plugin")
				module.exports = {
				  module: {
				    rules: [
				      {
					test: /\.vue$/,
					loader: 'vue',
					options: {
					  loaders: {
					    // 提取 <docs> 中的内容为原始文本
					    'docs': ExtractTextPlugin.extract('raw-loader'),
					  }
					}
				      }
				    ]
				  },
				  plugins: [
				    // 输出 docs 到当个文件中
				    new ExtractTextPlugin('docs.md')
				  ]
				}
			》生产环境构建
				生产环境打包要做两件事：
					》压缩应用代码
					》使用Vue.js 指南 删除警告 去除vue.js中的警告
					//webpack.config.js
					module.exports={
						plugins:[
							new webpack.DefinePlugin({//删除vue.js警告代码
							      'process.env': {
								NODE_ENV: '"production"'
							      }
							}),
							new webpack.optimize.UglifyJsPlugin({//压缩代码
							      compress: {
								warnings: false
							},
							new webpack.optimize.OccurrenceOrderPlugin()
						]
					}
					//显然我们不想在开发过程中使用这些配置，所以有几种方式解决这个问题：
					》使用环境变量动态构建
					》使用两个分开的 Webpack 配置文件，一个用于开发环境，一个用于生产环境。把可能共用的配置放到第三个文件中。
			》代码检验
				在.vue文件中你怎么检验你的代码，因为他不是js。我们假设你使用ESlint，如果没有使用的话，你应该去使用。
				你还需要eslint-plugin-html来支持提取并检验你的.vue文件中的js。
				确保把下面的配置加入到你的ESLint配置中：
					"plugins": [
					  "html"
					]
				在命令行这样使用：eslint --ext js,vue MyComponent.vue
				》另一种方法是使用eslint-loader，这样你的.vue文件会在开发期间每次保存时自动检验。
					npm install eslint eslint-loader --save-dev
					// webpack.config.js
					module.exports = {
					  // ... other options
					  module: {
					    loaders: [
					      {
						test: /.vue$/,
						loader: 'vue!eslint'
					      }
					    ]
					  }
					}
					//注意webpack loader处理顺序是从右往左的。确保在vue之前应用eslint，这样才能检验编译前的代码
					当我们需要考虑使用npm包中的第三方.vue组件，实际使用中我们希望使用vue-loader去处理第三方组件，但是不想检验它们。
					我们需要把linting配置到webpack的preLoaders中：
						// webpack.config.js
						module.exports = {
						  // ... other options
						  module: {
						    // only lint local *.vue files
						    preLoaders: [
						      {
							test: /.vue$/,
							loader: 'eslint',
							exclude: /node_modules/
						      }
						    ],
						    // but use vue-loader for all *.vue files
						    loaders: [
						      {
							test: /.vue$/,
							loader: 'vue'
						      }
						    ]
						  }
						}
						//webpack 2.x
						// webpack.config.js
						module.exports = {
						  // ... other options
						  module: {
						    rules: [
						      // only lint local *.vue files
						      {
							enforce: 'pre',
							test: /.vue$/,
							loader: 'eslint-loader',
							exclude: /node_modules/
						      },
						      // but use vue-loader for all *.vue files
						      {
							test: /.vue$/,
							loader: 'vue-loader'
						      }
						    ]
						  }
						}
			》测试
				webpack vue-cli模板为你提供预配置的单元测试和e2e测试设置。
				当测试*.vue文件时，我们不能使用给予CommonJs的简单测试运行器，因为他不知道如何处理*.vue文件。
				而是应该使用webpack + vue-loader打包我们的测试文件。推荐的设置是使用Karma和Karma-webpack。
				Karma是一个启动浏览器并为你运行测试的测试运行器。你可以选择要测试的浏览器以及你要使用的测试框架(如：Mocha或Jasmine)。
				以下是一个在PhantomJs中使用Jasmine测试框架运行测试的Karma配置示例：
				npm install karma karma-webpack karma-jasmine jasmine-core karma-phantomjs-launcher phantomjs --save-dev
				//我们只需要使用完全相同的webpack配置即可 但是的删除原来的entry 因为我们在测试期间不需要它
				var webpackConfig = require('./webpack.config.js')
				delete webpackConfig.entry
				//karma.conf.js
				module.exports = function (config) {
				  config.set({
				    browsers: ['PhantomJS'],
				    frameworks: ['jasmine'],
				    // 这是所有测试的入口文件。
				    files: ['test/index.js'],
				    // 把入口文件传给 webpack 以进行打包。
				    preprocessors: {
				      'test/index.js': ['webpack']
				    },
				    // 使用 webpack 配置
				    webpack: webpackConfig,
				    // avoid walls of useless text
				    webpackMiddleware: {
				      noInfo: true
				    },
				    singleRun: true
				  })
				}
				//test/index.js文件
				var testsContext = require.context('.', true, /\.spec$/)
				testsContext.keys().forEach(testsContext)
				//此入口文件只需要在同一文件夹中的.spec.js结尾引入其他所有文件。现在我们写一些测试：
				// test/component-a.spec.js
				var Vue = require('vue')
				var ComponentA = require('../../src/components/a.vue')
				describe('a.vue', function () {
				  // JavaScript 选项断言
				  it('should have correct message', function () {
				    expect(ComponentA.data().msg).toBe('Hello from Component A!')
				  })
				  // 组件实际渲染的渲染结果断言
				  it('should render correct message', function () {
				    var vm = new Vue({
				      template: '<div><test></test></div>',
				      components: {
					'test': ComponentA
				      }
				    }).$mount()
				    expect(vm.$el.querySelector('h2.red').textContent).toBe('Hello from Component A!')
				  })
				})
				//添加以下NPM脚本以运行测试：
				"scripts":{
					"test":"karma start karma.conf.js"
				}
				//最后运行：npm test
			》使用Mock测试
				在真实世界的应用中，我们的组件很可能具有外部依赖。在为组件编写单元测试时，理想的状态是我们可以模拟这些外部依赖关系。这样我们的测试只依赖被测组件的行为。
				vue-loader提供了一个可以使用inject-loader将任意依赖项注入到*.vue组件的特性。思路：我们使用inject-loader为该模块创建一个"模块工厂"功能，
				而不是直接导入组件模块，当使用mock对象调用此函数时，他会返回模块的实例并注入到mock中。
				案例：
				//example.vue
				<template>
					<div class='msg'>{{msg}}</div>
				</template>
				<script>
					//这个依赖需要被mocked
					import SomeService from '../service';
					export default {
					  data () {
					    return {
					      msg: SomeService.msg
					    }
					  }
					}
				</script>
				//使用mock导入的方法：
				npm install inject-loader@^2.0.0 --save-dev
				// example.spec.js
				const ExampleInjector = require('!!vue?inject!./example.vue')
					》!! 即禁用全局配置的所有loader
					》vue?inject! 使用vue-loader并传入?inject查询 告诉vue-loader在依赖注入模式下编译组件
					//返回的ExampleInjector是一个工厂函数，可以调用它来穿件example.vue模块的实例：
					const ExampleWithMocks = ExampleInjector({
					  // mock it
					  '../service': {
					    msg: 'Hello from a mocked service!'
					  }
					})
					//最后我们可以像往常一样测试组件：
					it('should render', () => {
					  const vm = new Vue({
					    template: '<div><test></test></div>',
					    components: {
					      'test': ExampleWithMocks
					    }
					  }).$mount()
					  expect(vm.$el.querySelector('.msg').textContent).toBe('Hello from a mocked service!')
					})
			》选项参考
				》webpack 1和2之间的使用差异
					//webpack2 配置直接放到loader rule中
					module.exports = {
					  // ...
					  module: {
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						options: {
						  // vue-loader options
						}
					      }
					    ]
					  }
					}
					//webpack1 在webpack配置中添加根节点vue块
					module.exports = {
					  // ...
					  vue: {
					    // vue-loader options
					  }
					}
				》loaders  类型{[lang:string]:string}
					指定webpack loader对象覆盖用于*.vue文件内的语言块的默认loader。如果指定，该键对应于语言块的lang属性。每种类型的默认lang是：
					》<tempalte> html
					》<script> js
					》<style> css
					如：使用babel-loader和eslint-loader处理所有的<script>块
					module: {
					  rules: [
					    {
					      test: /\.vue$/,
					      loader: 'vue-loader',
					      options: {
						loaders: {
						  js: 'babel-loader!eslint-loader'
						}
					      }
					    }
					  ]
					}
				》preLoaders  类型{[lang:string]:string}
					仅在>=10.3中支持
					配置格式和loaders相同，但是preLoaders会在默认loaders之前处理。你可以用来预处理语言块。一个常见用例是
					用来处理构建时的i18n。
				》postLoaders 类型{[lang:string]:string}
					仅在 >=10.3.0 版本中支持
					配置格式和loaders相同，但是postLoaders会在默认loaders之后处理。你可以用来后处理语言块。注意这会有些复杂：
					》对于html 默认loader返回结果会被编译为js渲染函数
					》对于css 由vue-style-loader返回的结果通常不太有用。使用postcss插件将会是更好的选择
				》postcss 类型 Array or Function Or Object
					注意：在>=11.0版本中，推荐使用PostCSS配置文件替代
					指定要应用于.vue文件中的css的自定义PostCSS插件。如果使用函数，函数将使用相同的loader上下文调用，并返回一个插件数组。
					{
					    loader: 'vue-loader',
					    options: {
					      // 注意：不要在 `loader` 下嵌入 `postcss` 选项
					      postcss: [require('postcss-cssnext')()],
					      loaders: {
						// ...
					      }
					    }
					  }
					  //这个配置项也可以是一个对象，这在使用依赖于自定义parser/stringifiers的项目会非常有用：
					  postcss: {
					    plugins: [...], // list of plugins
					    options: {
					      parser: sugarss // use sugarss parser
					    }
					  }
				》cssSourceMap 类型 Boolean  默认值 true
					是否开启css的source maps 关闭可以避免css-loader的some relative path related bugs 同时可以加快构建速度
					注意：这个值会在webpack配置中没有devtool的情况下自动设置为false
				》esModule 类型 Boolean  默认值undefined
					是否导出兼容esModule的代码，默认情况下vue-loader会导出commonjs格式，像module.exports=...。
					当esModule设置为true时，导出会变为exports.__esModule=true;exports=...。适用于与Babel以为的transpiler互操作如TypeScript。
				》preserveWhitespace 类型boolean 默认值true
					如果设置为false 模板中html标签之前的空格将会被忽略。
				》transformToRequire 类型 { [tag: string]: string | Array<string> }
					默认值: { img: 'src', image: 'xlink:href' }
					在模板编译过程中，编译器可以将某些属性。如src路径转换为require调用，以便目标资源可以由webpack处理。
					默认配置会转换<img>标签上的src属性和SVG的<image>标签上的xlink:href属性
				》buble  类型 Object  默认值{}
					配置buble-loader的选项(如果存在)，并且buble编译传递模板渲染函数。
					注意：在 9.x 版本中，模板表达式通过现在已经删除的 templateBuble 选项单独配置。
					模板渲染函数编译支持一个特殊的变换stripWith(默认启用)，它删除生产的渲染函数的with用法，使它们兼容严格模式。
					// webpack 1
					vue: {
					  buble: {
					    // 启用对象扩展运算符
					    // 注意：你需要自己提供 Object.assign polyfill！
					    objectAssign: 'Object.assign',

					    // turn off the `with` removal
					    transforms: {
					      stripWith: false
					    }
					  }
					}
					// webpack 2
					module: {
					  rules: [
					    {
					      test: /\.vue$/,
					      loader: 'vue-loader',
					      options: {
						buble: {
						  // same options
						}
					      }
					    }
					  ]
					}
				》extractCSS 12.0新增
					使用extract-text-webpack-plugin 自动提取css，适用于大多数预处理器，且也可在生产环境进行压缩。传入的值可以是true，
					也可以是插件的一个实例，这样可以为多个提取的文件使用多个提取插件的实例。
					这应当只用于生产环境，以便于可以在开发过程中使用热重载。
					// webpack.config.js
					var ExtractTextPlugin = require("extract-text-webpack-plugin")
					module.exports = {
					  // other options...
					  module: {
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						options: {
						  extractCSS: true
						}
					      }
					    ]
					  },
					  plugins: [
					    new ExtractTextPlugin("style.css")
					  ]
					}
					//传递插件的一个实例
					// webpack.config.js
					var ExtractTextPlugin = require("extract-text-webpack-plugin")
					var plugin = new ExtractTextPlugin("style.css")
					module.exports = {
					  // other options...
					  module: {
					    rules: [
					      {
						test: /\.vue$/,
						loader: 'vue-loader',
						options: {
						  extractCSS: plugin
						}
					      }
					    ]
					  },
					  plugins: [
					    plugin
					  ]
					}
20.生产环境部署
	》删除警告
		为了减少文件大小，Vue精简独立版本已经删除了所有警告，但是当你使用webpack或Browserify等工具时，你需要一些额外的配置实现这点
		》webpack
			使用webpack的DefinePlugin来指定生产环境，以便于在压缩时可以让UglifyJs自动删除代码块内的警告语句
			var webpack = require('webpack')
			module.exports = {
			  // ...
			  plugins: [
			    // ...
			    new webpack.DefinePlugin({
			      'process.env': {
				NODE_ENV: '"production"'
			      }
			    }),
			    new webpack.optimize.UglifyJsPlugin({
			      compress: {
				warnings: false
			      }
			    })
			  ]
			}
		》Browserify
			运行打包命令，设置NODE_ENV为'production'。等于告诉vueify避免引入热重载和开发相关代码。
			使用一个全局envify转换你的bundle文件。这可以精简掉包含在Vue源码中所有环境变量相关代码内的警告语句
			NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js
			使用vueify中包含的extract-css插件 提取样式到单独的css文件：
			NODE_ENV=production browserify -g envify -p [ vueify/plugins/extract-css -o build.css ] -e main.js | uglifyjs -c -m > build.js
	》跟踪运行时的错误
		如果在组件渲染时出现运行错误，错误将会被传递至全局Vue.config.errorHandler配置函数(如果已经设置)。
	》提取CSS
		使用单文件组件时，<style>标签在开发运行过程中会被动态实时注入。在生产环境中，你可能需要从所有组件中提取样式到单独的css文件中。
21.路由
	》安装
		》直接下载CDN
			Unpkg.com提供了基于npm的cdn连接。上面的链接会一直指向在NPM发布的最新版本。你也可以像
			https://unpkg.com/vue-router@2.0.0/dist/vue-router.js 这样制定版本号或tag
			<script src="/path/to/vue.js"></script>
			<script src="/path/to/vue-router.js"></script>
		》NPM
			npm install vue-router
			如果在一个模块化工程中使用它，必须要通过Vue.use()明确地安装路由功能：
			import Vue from 'vue';
			import VueRouter from 'vue-router';
			Vue.use(VueRouter);
			如果使用全局的script标签，则无须如此(手动安装);
		》构建开发版
			如果你想使用最新的开发版，就得从gitHub上直接clone，然后自己build一个vue-router
			git clone https://github.com/vuejs/vue-router.git node_modules/vue-router
			cd node_modules/vue-router
			npm install
			npm run build
	》基础
	     案例：
		html:
		<script src="https://unpkg.com/vue/dist/vue.js"></script>
		<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
		<div id='app'>
			<h1>Hello App</h1>
			<p>
				/*
					使用router-link组件来导航
					通过传入to属性指定链接
					<router-link>默认会被渲染成一个<a>标签
				*/
				<router-link to='/foo'>Go to Foo</router-link>
				<router-link to='/bar'>Go to Bar</router-link>
			</p>
			/*
			    路由出口，路由匹配到的组件将渲染在这里
			*/
			<router-view></router-view>
		</div>
		js:
			//如果使用模块化机制编程，遵循vue和vueRouter，要调用Vue.use(VueRouter);

		》定义路由组件，可以从其他文件import进来
			const Foo = {template:'<div>foo</div>'};
			const Bar = {template:'<div>bar</div>'};
		》定义路由
			每一个路由应该映射一个组件。其中'component'可以是通过Vue.extend()创建的组件构造器或者只是一个组件配置对象。
			const routers=[
				{
					path:'/foo',
					component:Foo
				},
				{
					path:'/bar',
					component:Bar
				}
			];
		》创建router实例 然后传入routes配置
			const router = new VueRouter({
				routes:routes
			});
		》创建和挂载根实例 //通过router配置参数注入路由，从而让整个应用都有路由功能
			const app = new Vue({
				router
			}).$mount('#app');
			//注意，当 <router-link></router-link>对应的路由匹配成功，将自动设置class属性值.router-link-active
	     》动态路由配置
		我们经常需要把某种模式匹配到的所有路由，全不映射到同一个组件。如：我们有一个User组件，对于所有ID各不相同的用户，都要使用这个组件
		来渲染。那么我们可以在vue-router的路由路径中使用"动态路径参数"
			const User={
				template:'<div>User</div>'
			}
			const router=new VueRouter({
				routes:[
					{
						path:'/user/:id',//动态路径参数以冒号开头
						component:User
					}
				]
			});
			//像/user/foo和/user/bar都将映射到相同的路由
			一个路径参数使用冒号:标记，当匹配到一个路由时，参数值会被设置到this.$route.params，可以在每一个组件内使用。
			const User = {
				template:'<div>User {{$route.params.id}}</div>'
			}
			//多段参数 /user/:username/post/:post_id
			》响应路由参数的变化
				当使用路由参数时，如从/user/foo导航到user/bar原来的组件实例会被复用，因为两个路由都渲染同一个组件
				比起销毁再创建，复用则显得更加高效。不过这也意味着组件的生命周期钩子不会被调用
				复用组件时，想对路由参数的变化做出响应的话，你可以简单地watch $route对象
				const User ={
					template:'...',
					watch:{
						'$route' (to,from){
							//对路由变化做出响应
						}
					}
				}
			》高级匹配模式
				vue-router使用path-to-regexp作为路径匹配引擎，所以支持很多高级的匹配模式：
				如：可选的动态路径参数
				    匹配零个或多个
				    一个或多个
				    甚至是自定义正则匹配
				    https://github.com/pillarjs/path-to-regexp#parameters
			》匹配优先级
				有时候，同一个路径可以匹配多个路由，此时匹配的优先级就按照路由的定义顺序：
				谁先定义的，谁的优先级就最高
		》嵌套路由
			实际应用界面，通常由多层嵌套的组件组合而成。同样的Url中各段动态路径也按某种结构对应嵌套的各层组件
			<div id='app'>
				<router-view></router-view>//最顶层的出口，渲染最高级路由匹配到的组件
			</div>
			const User ={
				//一个被渲染的组件同样可以包含自己嵌套的<router-view>
				template:'<h2>User {{$route.params.id}}</h2><router-view></router-view>'
			}
			const router=new VueRouter({
				routes:[
					{
						path:'/user/:id',
						component:User,
						children:[//要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置
							{	//当/user/:id/profile匹配成功，UserProfile会被渲染在User的<router-view>中
								path:'profile',
								component:UserProfile
							},
							{
								path:'posts',
								component:UserPosts
							},
							{
								path:'',//当/user/:id成功 显示
								component:UserDefault
							}
						]
					}
				]
			});
			//注意：以/开头的嵌套路径会被当做根路径，这让你充分的使用嵌套组件而无需设置嵌套的路径
			children配置就像routes配置一样的路由配置数组，所以你可以嵌套多层路由。
		》编程式的导航
			除了使用<router-link>创建a标签来定义导航链接，我们还可以借助router的实例方法，通过编写代码来实现。
			router.push(location)想要导航到不同的URl则使用router.push方法。这个方法会向history栈添加一个新的记录
			所以当用户点击浏览器后退按钮时则回到之前的Url。
			当你点击<router-link>时，这个方法会在内部调用，所以说点击<router-link :to='...'>等同于调用router.push(...);
			//声明式
			<router-link :to='...'>
			//编程式
			router.push(...);
			该方法的参数可以是一个字符串路径或者是一个描述地址的对象
				//字符串  router.push('home');
				//对象    router.push({path:'home'});
				//命名的路由  router.push({name:'user',params:{userId:123}});
				//带查询参数 编程/register?plan=private
					router.push({path:'register',query:{plan:'private'}});
			》router.replace(location);
				根router.push很像，唯一不同的就是，它不会向history添加新记录，而是根它的方法名一样
				替换掉当前history记录
				//声明式
				<router-link :to='...' replace>
				router.replace(...);
			》router.go(n)
				这个方法的参数是一个整数，意思是在history记录中向前或后退多少步，类似于history.go(n);
				//在浏览器记录中前进一步 等同于history.forward()
				router.go(1);
				//后退一步记录 等同于history.back()
				router.go(-1);
				//如果history记录不够用，那就失败
				router.go(100);
				router.go(-100);
			》操作history
				router.push router.replace router.go根history.pushState  history.replaceState history.go其实是差不多的
		》命名路由
			有时候，通过一个名称来标识一个路由显示的更方便一些，特别是在链接一个路由，或者是指向一些跳转的时候，你可以在创建router实例的时候，在routes配置中给某个路由设置名称
			const router =new VueRouter({
				routes:[
					{
						path:'/user/:userId',
						name:'user',//命名
						component:User
					}
				]
			});
			//要链接到一个命名路由，可以给router-link的to属性传一个对象
			<router-link :to='{name:"user",params:{userId:123}}'>User</router-link>
			等同于
			router.push({name:'user',params:{userId:123}});
		》命名视图
			有时候想同时在同级展示多个师徒，而不是嵌套展示。如：创建一个布局有sidebar侧导航和main主内容两个视图。这个时候命名视图就有用了
			你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口，如果router-view没有设置名字，那么默认为default
			<router-view>view one</router-view>
			<router-view name='a'>view two</router-view>
			<router-view name='b'>view three</router-view>
			//一个视图使用一个组件渲染，因此对于同一个路由，多个视图就需要多个组件。确保正确使用components配置：
				const router = new VueRouter({
					routes:[
						{
							path:'/',
							components:{//视图名称：组件名称
								default:Foo,
								a:Bar,
								b:Baz
							}
						}
					]
				});
		》重定向和别名
			重定向也是通过routes配置来完成的、
			案例：从/a重定向到/b
				//路径
				const router=new VueRouter({
					routes:[
						{path:'/a',redirect:'/b'}
					]
				});
				//重定向的目标也可以是一个命名的路由
				const router = new VueRouter({
					routes:[
						{path:'/a',redirect:{name:"foo"}}
					]
				});
				//重定向目标也可以是一个方法 动态的返回重定向目标
				const router = new VueRouter({
					routes:[
						{
							path:'/a',
							redirect:to =>{
								//方法接受 目标路由 作为参数
								//return重定向的字符串路径 或 路径对象
							}
						}
					]
				});
			》别名
				重定向的意思是，当用户访问/a时，URL将会替换成/b，然后匹配路由为/b。
				别名：/a的别名是/b，意味着，当用户访问/b时，url会保持为/b，但是路由匹配则为/a,就像用户访问/a一样。
					const router = new VueRouter({
						routes:[
							{
								path:'/a',
								component:A,
								alias:'/b'
							}
						]
					});
					//别名的功能让你可以自由地将UI结构映射到任意的URL，而不是受限于配置的嵌套路由结构。
		》html5 history模式
			vue-router默认hash模式--使用URL的hash来模拟一个完整的URL，于是当URL改变时，页面不会重新加载。
			如果不想要很丑的hash，我们可以用路由的history模式，这种模式充分利用history.pushState API来完成URL跳转而无须重新加载页面。
				const  router = new VueRouter({
					mode:'history',//指定路由的history模式
					routers:[...]
				});
				//当你使用history模式时，url就像正常的url一样，如：http://yoursite.com/user/id
				//不过这种模式要玩好，还需要后台配置的支持。因为我们的应用是一个单页客户端应用，如果后台没有正确的配置，
				当用户在浏览器直接访问 http://oursite.cim/user/id 就会返回404，所以你要在服务端增加一个覆盖所有情况的候
				选资源：如果url匹配不到任何静态资源，则应该返回同一个index.html页面，这个页面就是你app依赖的页面。
			》警告
				给一个警告，因为这么做以后，你的服务器就不在返回404错误页面，因为对于所有路径都会返回index.html文件。为了避免这种
				情况，你应该在Vue应用里面覆盖所有的路径情况，然后在给出一个404页面。
				const router = new VueRouter({
					mode:"history",
					routes:[
						path:'*',
						component:NotFoundComponent
					]
				});
				//或者如果你是用Node.js作为后台，你可以使用服务器的路由来匹配URL，
				当没有有匹配到路由的时候返回404，从而实现fallback
	》高级
		》导航钩子
			vue-router提供的导航钩子主要用来拦截导航，让它完成跳转或取消。
			有多种方式可以在路由导航发生时执行钩子：全局的，单个路由独享的，或者组件级的
			》全局钩子
				可以使用router.beforeEach注册一个全局的before钩子：
				const router = new VueRouter({...});
				router.beforeEach( (to,from,next) => {
					//每个钩子方法接收三个参数
					//to: Route 即将要进入的目标路由对象
					//from: Route 当前导航正要离开的路由对象
					//next: Function 一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数
						next():进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed(确认的)
						next(false):中断当前的导航。如果浏览器的URL改变了(可能是用户手动或浏览器后退按钮)，那么
							    URL地址会重置到from路由对应的地址
						next('/')或next({path:'/'})跳转到一个不同的地址。当前导航被中断，然后进行一个新的导航。
						//要确保调用next方法，否则钩子就不会被resolved
					//...
				});
				//当一个导航触发时，全局的before钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子resolve完之前一直处于等待中。
				》同样的可以注册一个全局的after钩子，不过他不像before钩子那样，after钩子没有next方法，不能改变导航。
					router.afterEach(route => {
						//...
					});
			》某个路由独享的钩子
				你可以在路由配置上直接定义beforeEnter钩子
				const router = new VueRouter({
					routes:[
						{
							path:'/foo';
							component:Foo,
							beforeEnter:(to,from,next) =>{//这些钩子与全局before钩子的方法参数是一样的
								//...to 就是上面的path
							}
						}
					]
				});
			》组件内的钩子
				可以在路由组件内直接定义以下路由导航钩子
				》beforeRouteEnter
				》beforeRouteUpdate
				》beforeRouteLeave
				const Foo = {
					template: '',
					beforeRouteEnter (to,from,next) {//在渲染该组件的对应路由被confirm前调用
						//不能获取组件实例 this 因为当钩子执行前，组件实例还没被创建
						//不过可以通过传入一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数
							next( vm => {
								//通过vm访问组件实例
							});
					},
					beforeRouteUpdate (to,from,next){//当前路由改变，但是该组件被复用时调用
						//如：对于一个带有动态参数的路径 /foo/:id 在/foo/1与/foo/2之间跳转的时候
						//由于会渲染同样的Foo组件，因此组件实例会被复用，而这个钩子就会在这个情况下被调用
						//可以访问组件实例  this
					},
					beforeRouteLeave (to,from,next){//导航离开该组件的对应路由时调用
						//可以访问组件实例 this。这个leave钩子通常用来禁止用户
						//在还未保存修改前突然离开。可以通过next(false)来取消导航
					}
				}
		》路由元信息
			定义路由的时候可以配置meta字段
				const router = new VueRouter({
					routes:[
						{
							path:'/foo',
							component:Foo,
							children:[
								{
									path:'bar',
									component:Bar,
									meta:{//meta属性
										requiresAuth:true
									}
								}
							]
						}
					]
				});
				//首先我们称呼routes配置中的每个路由对象为路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能
				//匹配多个路由记录 如：/foo/bar这个url将会匹配父路由记录以及子路由记录
				//一个路由匹配到的所有路由记录会暴露为$route对象(还有在导航钩子中的route对象)的$route.matched数组。因此我们需要
				//遍历$route.matched来检查路由记录中的meta字段
				》在全局导航钩子中检查meta字段
					router.beforeEach( (to,from,next)=> {
						if(to.matched.some( record => record.meta.requiresAuth )){
							if (!auth.loggedIn()) {
						            next({
							         path: '/login',
							         query: { redirect: to.fullPath }
						             })
						        } else {
						            next()
						        }
						}else {
							next();
						}
					});
		》过渡动效
			<router-view>是基本的动态组件，所以我们可以用<transition>组件给他添加一些过渡效果
				<transition>
					<router-view></router-view>
				</transition>
				//<transition>的所有功能在这里同样适用
			》单个路由的过渡
				上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，
				可以在各路由组件内使用<transition>并设置不同的name
				const Foo={
					template:`
						<transition name="slide">
							<div class='foo'>...</div>
						</transition>
					`
				}
				const Bar = {
					template:`
						<transition name="fade">
							<div class="bar">...</div>
						</transition>
					`
				}
			》基于路由的动态过渡
				还可以基于当前路由与目标路由的变化关系，动态设置过渡效果
				<transition :name="transitionName">//使用动态的transition name
					<router-view></router-view>
				</transition>
				//接着在父组件内 watch $route决定使用哪种过渡
				watch:{
					'$route' (to,from){
						const toDepth = to.path.split('/').length
						const fromDepth = from.path.split('/').length
						this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
					}
				}
		》数据获取	
			有时候，进入某个路由后，需要从服务器获取数据。如在渲染用户信息时，你需要从服务器获取用户
			的数据。我们可以通过两种方式来实现：
			》导航完成之后获取
				先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示加载中之类的指示
				当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的created钩子中获取数据
				这让我们有机会在数据获取期间展示一个loading状态，还可以在不同视图间展示不同的loading状态
				》案例
					<tempalte>
						<div class='post'>
							<div class='loading' v-if='loading'>
								Loading...
							</div>
							<div v-if='error' class='error'>
								{{error}}
							</div>
							<div v-if='post' class='content'>
								<h2>{{post.title}}</h2>
								<p>{{post.body}}</p>
							</div>
						</div>
					</tempalte>
					export default {
						data(){
							return {
								loading:false,
								post:null,
								error:null
							}
						},
						created (){//组件创建完后获取数据
							this.fetchData();
						},
						watch:{//如果路由有变化，会再次执行该方法
							'$route':'fetchData'
						}，
						methods:{
							fetchData (){
								this.error = this.post =null,
								this.loading=true;
								getPost(this.$route.params.id,(err,post)=>{
									this.loading =false;
									if(err){
										this.error = err.toString();
									}else {
										this.post =post;
									}
								});
							}
						}
					}
			》导航完成之前获取
				导航完成前，在路由的enter钩子中获取数据，在数据获取成功后执行导航
				通过这种方式，我们在导航转入新的路由前获取数据，我们可以在接下来的组件beforeRouteEnter
				钩子中获取数据，当数据获取成功后只调用next方法。
				export default {
					data (){
						return {
							post:null,
							error:null
						}
					},
					beforeRouteEnter (to,from,next){
						getPost (to.params.id,(err,post) => {
							if(err){
								next(false);
							}else {
								next (vm =>{
									vm.post=post;
								});
							}
						});
					},
					watch :{
						$route (){
							this.post=null;
							getPOst(this.$route.params.id,(err,post)=>{
								if(err){
									this.error=err.toString();
								}else {
									this.post=post;
								}
							});
						}
					}
				}
				//在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条
				或者别的提示。如果数据获取失败。同样有必要展示一些全局的错误提醒。
		》滚动行为
			使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。
			vue-router能做到，而且更好。它让你可以自定义路由切换时页面如何滚动。
			注意：这个功能只有在html5 history模式下可用
			当创建一个Router实例，你可以提供一个scrollBehavior方法
			const router=new VueRouter ({
				routes:[...],
				scrollBehavior (to,from,savedPosition){
					//to from路由对象
					//savedPosition当且仅当popstate导航(通过浏览器的前进/后退按钮触发)时可用
					//return 期望滚动到那个位置
					      //这个方法返回滚动位置的对象信息 {x:number,y:number} {selector:string}
					      //如果返回一个布尔 假值 或者是一个空对象 那么不会发生滚动
				}
				scrollBehavior (to,from,savedPosition){//对于所有的路由导航  简单的让页面滚动到顶部
					return {x:0,y:0}
				}
				scrollBehavior (to,from,savedPosition){//返回savedPosition 在按下后退或前进按钮时，就会想浏览器的原生表现那样
					if(savedPosition){
						return savedPosition;
					}else{
						return {x:0,y:0};
					}
				}
				scrollBehavior(to , from, savedPosition){//滚动到锚点
					if(to.hash){
						return{
							selector:to.hash
						}
					}
				}
			});
		》路由懒加载
			当打包构建应用时，js包会变得非常大，影响页面的加载。如果我们能把不同路由对应的组件
			分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更高效了
			结合 vue的 异步组件 和webpack的 code splitting feature即可实现路由组件的懒加载。
			》我们要做的就是把路由对应的组件定义成异步组件
				const Foo =resolve =>{//代码分块
					//require.ensure是webpack的特殊语法用来设置 code-split point
					require.ensure(['./Foo.vue'],() =>{
						resolve(require('./Foo.vue'));
					})
				}
				//另一种代码分块的语法 使用AMD风格的require 
					const Foo=resolve => require(['./Foo.vue'],resolve);
				//不需要改变任何路由配置 跟之前一样使用Foo
					const router=new VueRouter ({
						routes:[
							{
								path:'/foo',
								component:Foo
							}
						]
					});
			》把组件按组分块
				有时候我们想把某个路由下的所有组件都打包在同一个异步chunk中。只需要 给chunk命名，提供
				require.ensure第三个参数作为chunk的名称
				const Foo = r => require.ensure([], () => r(require('./Foo.vue')), 'group-foo')
				const Bar = r => require.ensure([], () => r(require('./Bar.vue')), 'group-foo')
				const Baz = r => require.ensure([], () => r(require('./Baz.vue')), 'group-foo')
				//webpack将相同的chunk下的所有异步模块打包到一个异步模块里面--这也意味着我们无须明确列出require.ensure的依赖(传入空数组就行)
	》API
		》<router-link>
			<router-link>组件支持用户在具有路由功能的应用中点击导航。通过to属性指定目标地址，默认渲染成带有正确链接的<a>标签，可以通过配置tag属性生成别的标签。
			另外当目标路由成功激活时，链接元素自动设置一个表示激活的css类名。
			<router-link> VS <a>:
				》无论是html5 history模式还是hash模式，它的表现行为一致，所以当你要切换路由模式，或者在ie9降级使用hash模式，
				   无须作任何变动
				》在html5 history模式下，router-link会拦截点击事件 让浏览器不在重新加载页面。
				》在html5 history模式下，使用base选项之后，所有的to属性都不需要写基路径了。
			》属性
				》to  类型 string 或  Location   必须的
					表示目标路由的链接，当被点击后，内部会立刻把to的值传到router.push(),
					所以这个值可以是一个字符串或者描述目标位置的对象
					//字符串
					<router-link to='home'>Home</router-link>
						//渲染结果
						<a href='home'>Home</a>
					//使用v-bind的js表达式
					<router-link v-bind:to="'home'">Home</router-link>
						//简写
						<router-link :to="'home'">Home</router-link>
						//同上
						<router-link :to="{path:'home'}">Home</router-link>
						//命名的路由
						<router-link :to="{name:'user,params:{userId:123}'}">User</router-link>
						//带查询参数 下面的结果为 /register?plan=private
						<router-link :to="{path:'register',query:{plan:'private'}}">Register</router-link>
				》replace  类型 boolean  默认值 false
					设置replace属性的话，当点击时，会调用router.replace()而不是router.push(),
					于是导航后不会留下history记录。
					<router-link :to="{path:'/abc'}" replace></router-link>
				》append  类型 boolean   默认值 false
					设置append属性后，则在当前(相对)路径前添加基路径。如：我们从/a导航到一个相对路径b
					如果没有配置append 则路径为/b 如果配了  则为/a/b
					<router-link :to="{path:'relative/path'}" append></router-link>
				》tag  类型 string  默认值 'a'
					有时候想要<router-link>渲染成某种标签如<li> 于是我们使用tag 属性指定何种标签，同样它还是会监听点击，触发导航。
					<router-link to='/foo' tag='li'>foo</router-link>
						//渲染结果
						<li>foo</li>
				》active-class 类型 string  默认值 'router-link-active'
					设置链接激活时使用的css类名。默认值可以通过路由的构造选项 linkActiveClass来全局配置
				》exact 类型 boolean 默认值false
					是否激活默认类名的依据是 inclusive match(全包含匹配).
					如：如果当前的路径是/a开头的，那么<router-link to='/a'>会被设置css类名
					按照这个规则，<router-link to='/'>将会点亮各个路由。想要链接使用"exact匹配模式"则使用exact属性。
					//这个链接只会在地址为/的时候被激活
					<router-link to='/' exact></router-link>
				》events 类型 string  或Array<string>  默认值 'click'
					声明可以用来触发导航的事件，可以是一个字符串或一个包含字符串的数组。
			》将"激活时的css类名"应用在外层元素
				有时候我们要让"激活时的css类名"应用在外层元素，而不是<a>标签本身，那么可以用
				<router-link>渲染外层元素包裹着内层的原生<a>标签
				<router-link tag='li' to='/foo'>
					<a>/foo</a>
				</router-link>
				//在这种情况下，<a>将作为真实的链接 它会获得正确的href  而激活的css类名则设置到外层的<li>
		》<router-view>
			<router-view>组件是一个functional组件，渲染路径匹配到的视图组件。<router-view>渲染的组件还可以内嵌自己的<router-view>
			根据嵌套路径渲染嵌套组件。
			》属性
				》name 类型 string  默认值 'default'
					如果<router-view>设置了名称，则会渲染对应的路由配置中components下的相应组件。
			》行为表现
				其他属性(非router-view使用的属性)都直接传给渲染的组件，很多时候，每个路由的数据都是包含在路由参数中。
				因为他也是个组件，所以可以配合<transition>和<keep-alive>使用，如果两个结合一起用，要确保在内层使用<keep-alive>
					<transition>
					  <keep-alive>
					    <router-view></router-view>
					  </keep-alive>
					</transition>
		》路由信息对象
			一个route object(路由信息对象) 表示当前激活的路由的状态信息，包含了当前的Url解析得到的信息
			还有url匹配到的route records(路由记录)。
			route object是immutable(不可变)的，每次成功的导航后都会产生一个新的对象。
			route object出现在多个地方：
				》组件内的this.$route和$route watcher回调 (监测变化处理);
				》router.match(location)的返回值
				》导航钩子的参数
					router.beforeEach( (to,from,next) =>{
						//to from 都是路由信息对象
					});
					scrollBehavior方法参数：
						const router=new VueRouter({
							scrollBehavior (to,from,savedPostion){
								//to from都是路由信息对象
							}
						});
			》路由信息对象的属性
				》$route.path  类型 string
					字符串 对应当前路由的路径，总是解析为绝对路径 如：'/foo/bar'
				》$route.params 类型 Object
					一个key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。
				》$route.query  类型 Object
					一个key/value对象，表示Url查询参数。如，对于路径/foo?user=1 则有$route.query.user == 1,
					如果没有查询参数 则是一个空对象。
				》$route.hash 类型 string
					当前路由的hash值(带#),如果没有hash值，则为空字符串
				》$route.fullPath 类型 string
					完成解析后的URL 包含查询参数和hash的完整路径
				》$route.matched 类型 Array<RouteRecord>
					一个数组，包含当前路由的所有嵌套路径片段的路由记录。路由记录就是routes配置数组中的对象副本(还有在children数组);
					const router = new VueRouter({
						routes:[
							{//该对象即为 route record
								path:'/foo',
								components:Foo
							},
							children:[
								{//该对象即为 route record
									path:'bar',
									component:Bar
								}
							]
						]
					});
					//当Url 为/foo/bar $route.matched将会是一个包含从上到下的所有对象(副本)
				》$route.name
					当前路由的名称
		》Router构造配置
			》routes  类型 Array<RouteConfig>
				RouteConfig的类型定义：
					declare  type  RouteConfig={
						path:string;
						component ?:Component;
						name ?:string;//命名路由
						components ?:{//命名视图组件
							[name:string]:Component
						},
						redirect ?:string | Location | Function
						alias ?: string | Array<string>
						children ?: Array<RouteConfig>
						beforeEnter ?: (to:Route,from:Route,next:Function)=> void
						meta ?: any
					}
			》mode 类型 string 默认值：'hash'(浏览器环境) | 'abstract'(Node.js)环境
				可选值："hash" | "history" | "abstract"
				配置路由模式：
					hash:使用Url hash值来作路由。支持所有浏览器 包括不支持html5 history Api的浏览器
					history:依赖html5 history API 和服务器配置
					abstract:支持所有js运行环境，如Node.js服务器端。如果发现没有浏览器的API 路由会自动强制进入这个模式
			》base  类型 string 默认值 '/'
				应用的基路径。如： 如果整个单页应用服务在/app/下，然后base就应该设为"/app/"
			》linkActiveClass 类型 string  默认值:'router-link-active'
				全局配置<router-link>的默认激活class类名
			》scrollBehavior  类型 Function
				(
				  to: Route,
				  from: Route,
				  savedPosition?: { x: number, y: number }
				) => { x: number, y: number } | { selector: string } | ?{}
		》Router 实例
			》属性
				》router.app 类型 Vue instance
					配置来router 的Vue根实例
				》router.mode 类型 string
					路由使用的 模式
				》router.currentRoute  类型 Route
					当前路由对应的路由信息对象
			》方法
				》router.beforeEach(guard);
				》router.afterEach(hook);
					//添加全局的导航钩子
				》router.push(location);
				》router.replace(location);
				》router.go(n);
				》router.back();
				》router.forward();
					//动态的导航到一个新的url
				》router.getMatchedComponents(location?);
					//返回目标位置或当前路由匹配的组件数组(是数组的定义/构造类，不是实例)。
					  通常在服务器端渲染的数据预加载时
				》router.resolve(location,current?,append?);
					//解析目标位置(格式和<router-link>的to属性一样) 返回包含如下属性的对象
					{
						location:Location;
						route:Route;
						href:string
					}
				》router.addRoutes(routes)
					动态添加更多的路由规则，参数必须是一个符合routes选项要求的数组
				》router.onReady(callback);
					添加一个会在第一次路由跳转完成时被调用的回调函数，此方法通常用于等待异步的导航钩子完成，如在进行服务端渲染的时候。
		》对组件注入
			》注入的属性
				通过Vue根实例的router配置传入router实例，下面这些属性会被注入到每个子组件
				》$router  router实例
				》$route  当前激活的路由信息对象，这个属性是只读的，里面属性是immutable(不可变的)
					  不过可以watch(检测变化)它
			》允许额外的配置
				》beforeRouteEnter
				》beforeRouteLeave				
22.状态管理
	》类Flux状态管理的官方实现
		由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。
		为了解决这个问题，Vue提供Vuex：我们有受到Elm启发的状态管理库。vuex甚至集成到了vue-devtools，无需配置即可访问时光旅行。
	》React的开发者
		如果你是来自React的开发者，你可能会对vuex和redux间的差异表示关注。redux是React生态环境中最流行的Flux实现。Redux事实上无法感知视图层，
		所以他能轻松的通过一些简单的绑定和Vue一起使用。vuex区别在于它是一个专门为vue应用所设计，这使得它能够更好地和vue进行整合。同时提供简
		洁的API和改善过的开发体验。
	》简单状态管理起步使用
		经常被忽略的是，vue应用中**原始数据对象**的实际来源，当访问数据对象时，一个Vue实例只是简单的代理访问，
		所以**如果你有一处需要被多个实例间共享的状态，可以简单的通过维护一份数据来实现共享**：
		const sourceOfTruth={};
		const vmA=new Vue({
			data:sourceOfTruth
		});
		const vmB=new Vue({
			data:sourceOfTruth
		});
		//现在当sourceOfTruth发生变法，vmA和vmB都将自动更新引用他们的视图，子组件们的每个实例也会通过this.$root.$data去访问。现在我们有了唯一的实际来源，但是
		调式将会成为噩梦。**任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录**。
		//为了解决这个问题，我们采用了一个简单的store模式：
			var store={
				debug:true,
				state:{
					message:'Hello!'
				},
				setMessageAction(newValue){
					this.debug && console.log('setMessageAction triggered with', newValue);
					this.state.message=newValue;
				},
				clearMessageAction(){
					this.debug && console.log('clearMessageAction triggered');
					this.state.message = 'clearMessageAction triggered';
				}
			}
			//需要注意，所有store中state的改变，都放置在store自身的action中去管理。
			这种集中式状态管理能够被更容易的理解哪种类型的mutation将会发生，以及它们是如何被触发，
			当错误出现时，我们现在也会有一个log记录bug之前发生了什么。
			//此外每个实例/组件仍然可以拥有和管理自己的**私有状态**
				var vmA = new Vue({
					data:{
						privateState:{},
						sharedState:store.state
					}
				});
				var vmB=new Vue({
					data:{
						privateState:{},
						sharedState:store.state
					}
				});
			//状态管理图
				Store------------
				  |manages      |
			    Shared State        |
			     | Trigger |        |
			     | Updates |	Notify Actions
			     |         |        |
			 Component  Component   |
			     |_________|________|
			 //注意：你不应该在action中**替换**原始的状态对象-组件和Store需要引用同一个共享对象，
			 mutation才能够被观察。
			 组件不允许直接修改属于store实例的state，而应该执行action来分发(dispatch)事件，通知store
			 去改变，我们最终达成了Flux架构。这样约定的好处是，我们能够记录所有的store中发生的state改变，
			 同时实现能做到记录变更(mutation)、保存状态快照，历史回滚/时光旅行的先进的调式工具。
	》vuex
		》安装
			》直接下载/CDN引用 https://unpkg.com/vuex
			  Unpkg.com 提供了基于 NPM 的 CDN 链接。以上的链接会一直指向 NPM 上发布的最新版本。
			  您也可以通过 https://unpkg.com/vuex@2.0.0 这样的方式指定特定的版本。
			  在Vue之后引入vuex会进行自动安装：
			  <script src="/path/to/vue.js"></script>
			  <script src="/path/to/vuex.js"></script>
			 》NPM
				npm install vuex --save
			 》Yarn
				yarn add vuex
				在一个模块化的打包系统中，你必须显示的通过Vue.use()来安装Vuex：
					import Vue from 'vue';
					import Vuex from 'vuex';
					Vue.use(Vuex);
				//当使用全局script标签引用Vuex时，不需要以上安装过程。
			 》自己构建
				如果需要使用dev分支下的最新版本，你可以直接从GitHub上克隆代码并自己构建
				git clone https://github.com/vuejs/vuex.git node_modules/vuex
				cd node_modules/vuex
				npm install
				npm run build
		》Vuex是什么？
			Vuex是一个专为Vue应用程序开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，
			并以相应的规则保证状态以一种可预测的方式发生变化。Vuex也集成到Vue的官网调试工具devtools
			extension，提供来诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。
			》什么是状态管理模式？
				案例：
				new Vue({
					data(){//state
						return {
							count:0
						}
					},
					template:"<div>{{count}}</div>"//view
					methods:{//actions
						increment(){
							this.count++;
						}
					}
				});
				//这个状态自管理应用包含以下几个部分：
					》state 驱动应用的数据源
					》view 以声明方式将state映射到视图
					》actions 响应在view上的用户输入导致的状态变化
					//单向数据流的理念示意图：
						 Actions
						|	|
					      View ―― State
				//但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：
					》多个视图依赖于同一状态
						传参的方法对于多层嵌套的组件将会非常的繁琐，并且对于兄弟组件间的状态传递无能为力
					》来自不同视图的行为需要变更同一状态
						我们经常会采用父子组件直接引用或通过事件来变更和同步状态的多份拷贝
					//以上的这些模式非常脆弱，通常会导致无法维护的代码
				//因此我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了
				  一个巨大的视图，不管在树的那个位置，任何组件都能获取状态或者触发行为！
				//另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护
				//上面两点就是Vuex背后的基本思想，借鉴来Flux、Redux、和The Elm Architecture，与其他模式不同的是，Vuex是专门为Vue
				设计的状态管理库，以利用**Vue的细粒度数据响应机制**来进行高效的状态更新。
			》什么情况下应该使用Vuex？
				虽然Vuex可以帮助我们管理共享状态，但是也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。
				如果您不打算开发大型的单页应用，使用Vuex可能是繁琐冗余的。确实是如此--如果你的应用够简单，最好不
				要使用Vuex。一个简单的global event bus就足够你所需了。但是如果你需要构建是一个中大型单页应用，您
				很可能会考虑如何更好地在组件外部管理状态，Vuex将会成为自然而然的选着。
	        》开始
			每一个Vuex应用的核心就是store(仓库)，store基本上就是一个容器，它包含着你的应用中大部分的状态(state)。
			Vuex和单纯的全局对象有以下两点不同：
				》Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应
				  的组件也会相应地得到高效更新。
				》你不能直接改变store中的状态。改变store中的状态的唯一途径就是显示地提交(commit)mutations。这样使得
				  我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好的了解我们的应用。
			》最简单的Store
				//安装Vuex之后，我们来创建一个store。
				  创建过程直接了当--仅需要提供一个初始化state对象和一些mutations：
					//如果在模块化构建系统中，请确保在开头调用Vue.use(Vuex);
					const store=new Vuex.Store({
						state:{
							count:0
						},
						mutations:{
							increment(state){
								state.count++;
							}
						}
					});
					//现在，可以通过store.state来获取状态对象，以及通过store.commit方法触发状态变更。
						store.commit('increment');
						store.state.count;//1
					//注意：我们通过提交mutation的方式，而非直接改变store.state.count，是因为我们想要更明确
					地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易
					地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照
					的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。
					//由于store中的状态是响应式的，在组件中调用store的状态简单到仅需要在**计算属性中返回**即可。触发
					  变化也仅仅是**在组件的methods中提交mutations**。
		》核心概念
			》State
				》单一状态树
					Vuex使用**单一状态树**--用一个对象就包含来全部的应用层状态，至此它变作为一个**唯一的数据源(SSOT)**
					而存在。这也意味着，每个应用将仅仅包含**一个store实例**。单一状态树让我们能够直接定位任一特定的状态
					片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。
					//单一状态树与模块化并不冲突--在后面的我们会讨论如果将状态和状态变更事件分布到各个子模块中。
				》在Vue组件中获得Vuex状态
					那么我们如何在Vue组件中展示状态呢？由于Vuex的状态存储是响应式的，从store实例中读取状态最简单的
					方法就是在**计算属性**中返回某个状态：
					//创建一个Counter组件
					const Counter ={
						template:`<div>{{count}}</div>`,
						computed:{
							count(){
								return store.state.count;
							}
						}
					}
					//每当store.state.count变化的时候，都会重新求取计算属性，并且触发更新相关联的DOM
					//然而，这种模式导致组件依赖的全局状态单例。在模块化的构建系统中，在每个需要使用
					  state的组件中都需要频繁地导入，并且在测试组件时需要模拟状态。
					》Vuex通过store选项，提供了一种机制将状态从根组件**注入**到每一个子组件中(需要调用Vue.use(Vuex));
						const app=new Vue({
							el:'#app',
							//把store对象提供给'store'选项，这可以把store的实例注入到所有的子组件
							store,
							components:{
								Counter
							},
							template:`
								<div class='app'>
									<counter></counter>
								</div>
							`
						});
						//通过在根实例中注册的store选项，该store实例会注入到根组件下的所有子组件中，且子组件能通过
						  this.$store访问到
						  const Counter ={
							template:`<div>{{count}}</div>`,
							computed:{
								count(){
									return this.$store.state.count;
								}
							}
						  }
				》mapState辅助函数
					当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用
					**mapState辅助函数帮助我们生成计算属性**。
					//在单独构建的版本中辅助函数为Vuex.mapState
					import {mapState} from 'vuex';
					export default {
						//...
						computed:mapState({
							//箭头函数使代码更简练
							count:state => state.count,
							//传字符串参数 'count' 等同于 state => state.count
							countAlias:'count',
							//为了能够使用 this获取局部状态 必须使用常规函数
							countPlusLocalState (state){
								return state.count + this.localCount
							}
						});
					}
					//当映射的计算属性的名称与state的子节点名称相同时，我们也可以给mapState传一个字符串数组
						computed:mapState([
							'count'//映射this.count为store.state.count
						]);
				
				》对象展开运算符
					mapState函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常我们需要使用一个工具函数将多个对象
					合并为一个对象，以使我们可以将最终对象传给computed属性。但是有了对象展开运算符，我们可以极大的简化写法：
					computed:{
						localComputed(){
							//...
						},
						...mapState({//使用对象展开运算符将此对象混入到外部对象中
							//...
						});
					}
				》组件仍然保有局部状态
					使用Vuex并不意味着你需要将所有的状态放入Vuex。虽然将所有的状态放到Vuex会使得状态变化更显示和易调试，
					但是也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根
					据你的应用开发需要进行权衡和确定。	
			》Getters
				有时候我们需要从store中的state中派生一些状态，如：对列表进行过滤并计数：
					computed:{
						doneTodosCount(){
							return this.$store.state.todos.filter(todo => todo.done).length
						}
					}
				//如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数，然后再多处导入它--无论那种方式都不是很理想。
				》Vuex允许我们再store中定义**getters(可以认为是store的计算属性)**。Getters接受state作为其第一个参数：
					const store = new Vuex.Store({
						state:{
							todos:[
								{id:1,text:'...',done:true},
								{id:2,text:'...',done:false}
							]
						},
						getters:{
							doneTodos:state => {
								return state.todos.filter(todo => todo.done);
							},
							doneTodosCount:(state,getters)=>{//Getters也可以接受其他getters作为第二个参数
								return getters.doneTodos.length;
							}
						}
					});
					//Getters会暴露为store.getters对象：
						store.getters.doneTodos //[{ id: 1, text: '...', done: true }]
						store.getters.doneTodosCount;//1
					//我们可以很容易地在任何组件中使用它
						computed:{
							doneTodosCount(){
								return this.$store.getters.doneTodosCount;
							}
						}
				》mapGetters辅助函数
					mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：
						import {mapGetters} from 'vuex';
						export default{
							computed:{
								//使用对象展开运算符将getters 混入computed对象中
								...mapGetters([
									'doneTodosCount',
									'auotherGetter',
									//...
								]);
								//如果你想将一个getter属性另取一个名字，使用对象形式：
								...mapGetters({
									// 映射 this.doneCount 为 store.getters.doneTodosCount
									doneCount:'doneTodosCount'
								});
							}
						};
			》Mutations
				更改Vuex的store中的状态的唯一方法是提交mutation。
				Vuex中的mutations非常类似于事件：每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。这个回调函数就是
				我们实际进行状态更改的地方，并且它会接受state作为第一个参数。
					const store = new Vuex.Store({
						state:{
							count:1
						},
						mutations:{
							increment(state){//type:'increment' 此函数作为handler
								state.count++;//变更状态
							}
						}
					});
					//你不能直接调用一个mutaion handler。这个选项更像是事件注册：当触发一个**类型为increment**的mutation时，调用此函数。
					//要唤醒一个mutation handler 需要以相应的type调用store.commit方法。
						store.commit('increment');
				》提交载荷 Payload
					可以向store.commit传入额外的参数，即mutation的载荷(payload)
					mutations:{
						increment(state,n){
							state.count += n;
						}
					}
					store.commit('increment',10);
					//在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读：
						mutations：{
							increment(state,payload){
								state.count +=playload.amount;
							}
						}
						store.commit('increment',{
							amount:10
						});
				》对象风格的提交方式
					提交mutation的另一种方式是直接使用包含type属性的对象：
						store.commit({
							type:'increment',
							amount:10
						});
					//使用对象风格的提交方式，整个对象都作为载荷传给mutation函数，因此handler保持不变：
						mutations:{
							increment(state,payload){
								state.count += payload.amount;
							}
						}
				》Mutations 需遵守Vue的响应规则
					既然Vuex的store中的状态是响应式的，那么当我们变更状态时，监视状态的Vue组件也会自动更新。
					这也意味着Vuex中的mutation也需要与使用Vue一样遵守一些注意事项：
					》最好提前在你的store中初始化好所有所需属性。
					》当需要在对象上添加新属性时，你应该
						》使用Vue.set(obj,'newProp',123);
						》以新对象替换老对象
							state.obj={...state.obj,newProp:123}
				》使用常量替代Mutation事件类型
					使用常量替代mutation事件类型在各种Flux实现中是很常见的模式。这样可以使linter之类的工具发挥作用，
					同时把**这些常量放在单独的文件中**可以让你的代码合作者对整个app包含的mutation一目了然：
					//mutation-types.js 文件
					export const SOME_MUTATION='SOME_MUTATION';
					//store.js
					import Vuex from 'vuex';
					import {SOME_MUTATION} from './mutation-types';
					const store=new Vuex.Store({
						state:{...},
						mutations:{
							//使用常量作为函数名
							[SOME_MUTATION](state){
								//...
							}
						}
					});
					//用不用常量取决于你--在需要多人协作的大型项目中，这会很有帮助。
				》mutation必须是同步函数
					一条重要的原则就是要记住mutation必须是**同步函数**
					错误案例：
					mutations:{
						someMutation(state){
							//异步执行
							api.callAsyncMethod(()=>{
								state.count++;
							});
						}
					}
					现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，
					devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的
					回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候
					回调函数实际上被调用 ―― 实质上任何在回调函数中进行的的状态的改变都是不可追踪的。
				》在组件中提交Mutations
					你可以在组件中使用this.$store.commit('xxx')提交mutation，或者使用mapMutations辅助函数将组件中的
					methods映射为store.commit调用--需要在根节点注入store
					import {mapMutations} from 'vuex';
					export default{
						methods:{
							...mapMutations([//数组
								'increment' // 映射 this.increment() 为 this.$store.commit('increment')
							]),
							...mapMutations({//对象
								add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')
							})
						}
					}
				》Actions
					在mutation中混合异步调用会导致你的程序很难调试。如当你调用两个包含异步回调的mutation来改变状态，你无法确定那个先回调。这就是为什么
					我们要区分这两个概念。在Vuex中，mutation都是**同步事务**。
					store.commit('increment');//任何由'increment'导致的状态变更都应该在此刻完成。
					Actions用于处理异步操作。	
			》Actions
				Action类似于mutation，不同于：
					》Action提交的是mutation，而不是直接变更状态
					》Action可以包含任意异步操作
				》注册一个简单的action
					const store=new Vuex.Store({
						state:{
							count:0,
						},
						mutations:{
							increment(state){
								state.count++;
							}
						},
						actions:{
							increment(context){
								context.commit('increment');
							}
						}
					});
					Action函数接受一个与store实例具有相同方法和属性的context对象，因此你可以调用context.commit提交一个mutation
					或者通过context.state和context.getters来获取state与getters。
					//实践中我们会经常用到Es6de参数解构来简化代码--特别是我们需要调用commit很多次的时候
						actions：{
							increment({commit}){
								commit('increment');
							}
						}
				》分发Action
					Action通过store.dispatch方法触发：
						store.dispatch('increment');
					//在action内部执行异步操作
						actions：{
							incrementAsync({commit}){
								setTimeout(()=>{
									commit('increment');
								},1000);
							}
						}
					//Actions支持同样的载荷方式和对象方式进行分发
						//以载荷形式分发
						store.dispatch('incrementAsync',{
							amount:10
						});
						//以对象形式分发
						store.dispatch({
							type:'incrementAsync',
							amount:10
						});
					//购物车案例
						actions:{
							checkout({commit,state},products){//context,playload
								//把当前购物车的物品备份
								const savedCartItems=[...state.cart.added];
								// 发出结账请求，然后乐观地清空购物车
							        commit(types.CHECKOUT_REQUEST)
							        // 购物 API 接受一个成功回调和一个失败回调
							        shop.buyProducts(
							          products,
							          // 成功操作
							          () => commit(types.CHECKOUT_SUCCESS),
							          // 失败操作
							          () => commit(types.CHECKOUT_FAILURE, savedCartItems)
							    )
							}
						}
						//注意我们正在进行一系列的异步操作，并且通过提交mutation来记录action产生的副作用--即状态变更
				》在组件中分发Action
					在组件中使用this.$store.dispatch('xxx')分发action或者使用mapActions辅助函数将组件的methods映射为
					store.dispatch调用(需要先在根节点注入store)。
					import {mapActions} from 'vuex';
					export default{
						methods:{
							...mapActions([//数组
								'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')
							])，
							...mapActions({//对象
								add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')
							})
						}
					}
				》组合Actions
					Action通常是异步的，那么如何知道action什么时候结束呢？更重要的是我们如何才能组合多个action，以处理
					更加复杂的异步流程？
					首先你需要明白store.dispatch可以处理被触发的action的回调函数返回的Promise，并且store.dispatch仍旧返回Promise：
						actions:{
							actionA({commit}){
								return new Promise((resolve,reject)=>{
									setTimeout(() =>{
										commit('someMutation');
										resolve();
									},1000);
								});
							}
						}
						store.dispatch('actionA').then(()=>{
							//...
						});
						//在另一个action中
						actions ：{
							actionB({dispatch,commit}){
								return dispatch('actionA').then(()=>{
									commit('someOtherMutation');
								});
							}
						}
						//最后如果我们利用async await 这个js即将到来的新特性
							//假设getData()和getOtherData()返回的是Promise
							actions: {
							  async actionA ({ commit }) {
							    commit('gotData', await getData())
							  },
							  async actionB ({ dispatch, commit }) {
							    await dispatch('actionA') // 等待 actionA 完成
							    commit('gotOtherData', await getOtherData())
							  }
							}
						//一个store.dispatch在不同的模块中可以触发多个action函数，在这种情况下，只有当所有触发函数完成后，返回的Promise才会执行。
			》Modules
				使用单一状态树，导致应用的所有状态集中到一个很大的对象，但是当应用变的很大的时候，store对象会变得臃肿不堪。
				为了解决以上问题，Vuex允许我们将store分割到模块(module),每个模块拥有自己的state、mutation、action、getters，甚至是嵌套子模块--从上至下进行类似的分割：
					const moduleA={
						state:{},
						mutations:{},
						actions:{},
						getters:{}
					}
					const moduleB={
						state:{},
						mutations:{},
						actions:{}
					}
					const store=new Vuex.Store({
						modules:{
							a:moduleA,
							b:moduleB
						}
					});
					store.state.a//moduleA的状态
					store.state.b//moduleB的状态
				》模块的局部状态
					对于模块内部的mutation和getter，接受的第一个参数是模块的局部状态
						const moduleA={
							state:{
								count:0,
							},
							mutations:{
								increment(state){
									state.count++;//state --模块的局部状态
								}
							},
							getters:{
								doubleCount(state){
									return state.count * 2;
								}
							}
						}
					//同样对于模块内部的action，context.state是局部状态，根节点的状态是context.rootState:
						const moduleA={
							actions:{
								incrementIfOddOnRootSum({state,commit,rootState}){
									if((state.count + rootState.count) % 2===1){
										commit('increment');
									}
								}
							}
						}
					//对于模块内部的getter，根节点状态会作为第三个参数：
						const moduleA={
							getters:{
								sumWithRootCount(state,getters,rootState){
									return state.count + rootState.count;
								}
							}
						}
				》命名空间
					模块内部的action,mutation和getter现在仍然注册在全局命名空间--这样保证了多个模块能够响应同一个
					mutation或action。你可以通过添加前缀或后缀的方式隔离各模块，以避免名称冲突。你也可能希望写出一
					个可复用的模块，其使环境不可控。
					//案例--创建一个todos模块
					//types.js
						//定义getter action mutation的名称为常量以模块名'todos'为前缀
						export const DONE_COUNT='todos/DONE_COUNT';
						export const FETCH_ALL='todos/FETCH_ALL';
						export const TOGGLE_DONE='todos/TOGGLE_DONE';
					//modules/todos.js
						import * as types from './types';
						//使用添加了前缀的名称定义 getter action mutation
						const todosModule = {
						  state: { todos: [] },
						  getters: {
						    [types.DONE_COUNT] (state) {
						      // ...
						    }
						  },
						  actions: {
						    [types.FETCH_ALL] (context, payload) {
						      // ...
						    }
						  },
						  mutations: {
						    [types.TOGGLE_DONE] (state, payload) {
						      // ...
						    }
						  }
				》模块动态注册
					在store创建之后，你可以使用store.registerModule方法注册模块：
						store.registerModule('myModule',{
							//...
						});
					//模块的状态将是store.state.myModule
					//模块动态注册功能可以让其他Vue插件为了应用的store附加新模块，以此来分割Vuex的状态管理。如：
					  vuex-roter-sync插件可以集成vue-router与vuex，管理动态模块的路由状态。
					//也可以使用store.unregisterModule(moduleName)动态地卸载模块。
					  注意：不能使用该方法卸载静态模块(在创建store时声明的模块)
		》项目结构
			Vuex并不限制你的代码结构,但是它规定了一些需要遵守的规则：
				》应用层级的状态应该集中到单个store对象中
				》提交的mutation是更改状态的唯一方法，并且这个过程是同步的
				》异步逻辑都应该封装到action里面
				//只要你遵守以上规则，如何组织代码随你，如果你的store文件太大，只需要将action mutation getters分割到单独的文件。
				//对于大型应用，希望把vuex相关代码分割到模块中，项目结构示例如下：
					├── index.html //单页面入口文件
					├── main.js //入口js
					├── api
					│   └── ... # 抽取出API请求
					├── components //单文件组件
					│   ├── App.vue
					│   └── ...
					└── store //vuex相关文件
					    ├── index.js          # 我们组装模块并导出 store 的地方
					    ├── actions.js        # 根级别的 action
					    ├── mutations.js      # 根级别的 mutation
					    └── modules
						├── cart.js       # 购物车模块
						└── products.js   # 产品模块
		》插件
			Vuex的store接受plugins选项，这个选项暴露出每次mutation的钩子。Vuex插件就是一个函数，它接受store作为**唯一**参数：
				const myPlugin= store =>{
					//store初始化后调用
					store.subscribe( (mutation,state)=>{
						//每次mutation之后调用 mutation格式为{type,payload}
					});
				}
				//添加插件
				const store=new Vuex.Store({
					plugins:[myPlugin]
				});
			》在插件内提交Mutation
				在插件中不允许直接修改状态--类似于组件，只能通过提交mutation来触发变化。
				通过提交mutation，插件可以用来同步数据源到store。如：同步websocket数据源
				到store。
				export default function createWebSocketPlugin (socket){
					return store =>{
						socket.on('data',data=>{
							store.commit('receiveData',data);
						});
						store.subscribe(mutation =>{
							if(mutation.type === 'UPDATE_DATA'){
								socket.emit('update',mutation.payload);
							}
						});
					}
				}
				const store=new Vuex.Store({
					state,
					mutations,
					plugins:[createWebSocketPlugin(socket)]
				});
			》生成State快照
				有时候插件需要获得状态的 **快照**,比较改变的前后状态，想要实现这项功能，需要对状态对象进行深拷贝：
				const myPluginWithSnapshot = store =>{
					let prevState=_.cloneDeep(store.state);
					store.subscribe((mutation,state)=>{
						let nextState = _.cloneDeep(state);
						//比较prevState与nextState--快照

						//保存状态，用于下一次mutation
						prevState=nextState;
					});
				}
				//生成状态快照的插件应该只在开发阶段使用，使用webpack或browserify，让构建工具帮我们处理：
					const store=new Vuex.Store({
						plugins:process.env.NODE_ENV !== 'production'?[myPluginWithSnapshot]:[],
					});
					上面插件会默认启用。在发布阶段，你需要使用 Webpack 的 DefinePlugin 或者是 
					Browserify 的 envify 使 process.env.NODE_ENV !== 'production' 为 false。
			》内置Logger插件
				如果正在使用vue-devtools，可能不需要此插件。
				Vuex自带来一个日志插件用于一般的调试：
					import createLogger from 'vuex/dist/logger';
					const store = new Vuex.Store({
						plugins:[createLogger()]
					});
				》createLogger函数有几个配置项
					const logger = createLogger({
						collapsed:false,//自动展开记录的mutation
						filter (mutation,stateBefore,stateAfter){
							//当需要某个mutation {type,payload}被记录时，return true
							return mutation.type !== "aBlacklistedMutation";
						},
						transformer (state) {
						    // 在开始记录之前转换状态
						    // 例如，只返回指定的子树
						    return state.subTree
						  },
						  mutationTransformer (mutation) {
						    // mutation 按照 { type, payload } 格式记录
						    // 我们可以按任意方式格式化
						    return mutation.type
						  }
					});
					//日志插件还可以直接通过<script>标签引入，它会提供全局方法 createVuexLogger。
					注意：logger插件会生成状态快照，所以仅在开发环境使用。
		》严格模式
			开启严格模式，仅需要在创建store的时候传入strict:true：
				const store=new Vuex.Store({
					//...
					strict:true
				});
			//在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。
			这能保证所有的状态变更都能被调试工具跟踪到。
			》开发环境与发布环境
				**不要在发布环境下启用严格模式**，严格模式会深度监测状态树来检测不合规的状态变更。--请确保在发布环境下关闭严格模式，以避免性能损失。
				类似于插件，我们可以让构建工具来处理这种情况：
				const store = new Vuex.Store({
				        //...
					strict: process.env.NODE_ENV !== 'production'
				});
		》表单处理
			当在严格模式中使用Vuex时，在属于Vuex的state上使用v-model会比较棘手：
			<input v-model='obj.message'/>
			假设这里的obj是在计算属性中返回的一个属于vuex store的对象，在用户输入时，v-model会试图直接修改
			obj.message。在严格模式下，由于这个修改不是在mutation函数中执行的，这里会抛出一个错误。
			》用vuex的思维去解决这个问题的方法是：给<input>中绑定value然后监听input或change事件，在事件回调中调用action：
				<input :value='message' @input="updateMessage"/>
				computed:{
					...mapState({
						message:state=>state.obj.message
					});
				}
				methods:{
					updateMessage(e){
						this.$store.commit('updateMessage',e.target.value);
					}
				}
				//下面是mutation函数
				mutations:{
					updateMessage(state,message){
						state.obj.message=message;
					}
				}
			》双向绑定的计算属性
				必须承认，这样做比简单地使用"v-model+局部状态"要嗦得多，并且也损失了一些v-model中很有用的特性。
				另一个方法是使用带有setter的双向绑定计算属性：
					<input v-model='message'/>
					computed:{
						message:{
							get(){
								return this.$store.state.obj.message;
							},
							set(value){
								this.$store.commit('updateMessage',value);
							}
						}
					}
		》测试
			我们主要想针对Vuex中的mutations和actions进行单元测试。
			》测试Mutations
				Mutations很容易被测试，因为它们仅仅是一些完全依赖参数的函数。这里有个小技巧，如果你在store.js文件中定义了
				mutations，并且使用了Es6的模块功能默认输出了Vuex.store的实例，那么你仍然可以给mutation取一个变量名然后把
				它输出去：
				const state={...}
				//mutations作为命名输出对象
				export const mutations={...}
				export default new Vuex.Store({
					state,
					mutations
				});
				》下面是用Mocha+Chai测试一个mutation的例子--实际上你可以用任何你喜欢的测试框架
					//mutations.js
					export const mutations={
						increment:state=>state.count++,
					}
					//mutations.spec.js
					import {expect} from 'chai';
					import {mutations} from './store';
					//解构mutations
					const {increment} =mutations;
					describe('mutations',()=>{
						it('INCREMENT'),()+>{
							//模拟状态
							const state={count:0};
							//应用mutation
							increment(state);
							//断言结果
							expect(state.count).to.equal(1);
						}
					})
			》测试Actions
				Actions应对起来略微棘手，因为它们可能需要调用外部的API。当测试actions的时候，我们需要增加一个mocking服务层
				--如我们可以把API调用抽象成服务，然后在测试文件中用mock服务回应API调用。为了便于解决mock依赖，可以用webpack
				和inject-loader打包测试文件。
				》测试异步action的例子
					//actions.js
					import shop from '../api/shop';
					export const getAllProducts=({commit})=>{
						commit('REQUEST_PRODUCTS');
						shop.getProducts(products => {
							commit('RECEIVE_PRODUCTS', products);
						});
					};
					//actions.spec.js
					//使用require语法处理内联loaders,inject-loader返回一个允许我们注入mock依赖的模块工厂
					import {expect} from 'chai';
					const actionsInjector = require('inject!./actions');
					//使用mocks创建模块
					const actions=actionsInjector({
						'../api/shop':{
							getProducts(cb){
								setTimeout(()=>{
									cb([/*mocked 响应*/]);
								},100);
							}
						}
					});
					//用指定的mutations测试action的辅助函数
					const testAction=(action,args,state,expectedMutations,done)=>{
						let count=0;
						//模拟提交
						const commit =(type,payload)=>{
							const mutation=expectedMutations[count];
							expect(mutation.type).to.equal(type);
							if(payload){
								expect(mutation.payload).to.deep.equal(payload);
							}
							count++;
							if(count>=expectedMutations.length){
								done();
							}
							//用模拟的store和参数调用action
							action({commit,state},...args);
							//检查是否没有mutation被dispatch
							if(expectedMutations.length === 0){
								expect(count).to.equal(0);
								done();
							}
						}
						describe('actions',() =>{
							it('getAllProducts',done=>{
								testAction(actions.getAllProducts,[],{},[
									{ type: 'REQUEST_PRODUCTS' },
									{ type: 'RECEIVE_PRODUCTS', payload: { /* mocked response */ } }
								],done);
							});
						});
					}；
			》测试Getters
				如果你的getter包含很复杂的计算过程，很有必要测试它们。Getter的测试与mutation一样直截了当。
				测试一个Getter的示例：
				//getters.js
				export const getters={
					filteredProducts(state,{filterCategory}){
						return state.products.filter(product =>{
							return product.category === filterCategory;
						});
					}
				}
				//getters.spec.js
				import {expect} from 'chai';
				import {getters} from './getters';
				describe('getters',() =>{
					it('filteredProducts',()=>{
						    // 模拟状态
						    const state = {
						      products: [
							{ id: 1, title: 'Apple', category: 'fruit' },
							{ id: 2, title: 'Orange', category: 'fruit' },
							{ id: 3, title: 'Carrot', category: 'vegetable' }
						      ]
						    }
						    // 模拟 getter
						    const filterCategory = 'fruit';
						    //获取getter的结果
						    const result=getters.getters.filteredProducts(state, { filterCategory });
						    // 断言结果
						    expect(result).to.deep.equal([
						      { id: 1, title: 'Apple', category: 'fruit' },
						      { id: 2, title: 'Orange', category: 'fruit' }
						    ])

					});
				});
			》执行测试
				如果你的mutations和actions编写正确，经过合理的mocking处理之后，这些测试应该不依赖任何浏览器API，因此你可以直接用
				webpack打包这些测试文件然后在Node中执行。换一种方式，你也可以用mocha-loader或Karma+Karma-webpack在真实浏览器环境
				中进行测试。
			》在Node中执行测试
				创建一下webpack配置
				// webpack.config.js
				module.exports = {
				  entry: './test.js',
				  output: {
				    path: __dirname,
				    filename: 'test-bundle.js'
				  },
				  module: {
				    loaders: [
				      {
					test: /\.js$/,
					loader: 'babel-loader',
					exclude: /node_modules/
				      }
				    ]
				  }
				}
				然后：
				webpack
				mocha test-bundle.js
			》在浏览器中测试
				》安装 mocha-loader
				》把上述 webpack 配置中的 entry 改成 'mocha!babel!./test.js'
				》用以上配置启动 webpack-dev-server
				》访问 localhost:8080/webpack-dev-server/test-bundle.
		》热重载
			使用webpack的Hot Module Replacement API,Vuex支持在开发过程中热重载mutation、modules、actions、和getters。
			你也可以在Browserify中使用browserify-hmr插件。
			对于mutation和模块，你需要使用store.hotUpdate()方法：
			// store.js
			import Vue from 'vue'
			import Vuex from 'vuex'
			import mutations from './mutations'
			import moduleA from './modules/a'

			Vue.use(Vuex)

			const state = { ... }

			const store = new Vuex.Store({
			  state,
			  mutations,
			  modules: {
			    a: moduleA
			  }
			})
			if (module.hot) {
			  // 使 actions 和 mutations 成为可热重载模块
			  module.hot.accept(['./mutations', './modules/a'], () => {
			    // 获取更新后的模块
			    // 因为 babel 6 的模块编译格式问题，这里需要加上 .default
			    const newMutations = require('./mutations').default
			    const newModuleA = require('./modules/a').default
			    // 加载新模块 
			    store.hotUpdate({
			      mutations: newMutations,
			      modules: {
				a: newModuleA
			      }
			    })
			  })
			}
		》API文档
			》Vuex.Store
				import Vuex from 'vuex';
				const store=new Vuex.Store({
					//...options
					//Vuex.Store构造器选项
					》state 类型Object
					》mutations 类型 { [type:string]:Function }
						在store上注册的mutation，处理函数总是接受state作为第一个参数(如果定义在模块中，则为模块的局部状态)
						payload作为第二个参数(可选)
					》actions  类型 { [type:string]:Function }
						在store上注册的action。处理函数接受一个context对象，包含以下属性：
						{
							  state,     // 等同于 store.state, 若在模块中则为局部状态
							  rootState, // 等同于 store.state, 只存在于模块中
							  commit,    // 等同于 store.commit
							  dispatch,  // 等同于 store.dispatch
							  getters    // 等同于 store.getters
						}
					》getters 类型 { [key:string]:Function }
						在store上注册的getter，getter方法接受以下参数：
						state,//如果在模块中定义则为模块的局部状态
						getters,//等同于store.getters
						rootState,//等同于store.state
						注册的getter暴露为store.getters。
					》modules  类型Object
						包含了子模块的对象，会被合并到store，大概如下：
						{
						  key: {
						    state,
						    mutations,
						    actions?,
						    getters?,
						    modules?
						  },
						  ...
						}
						与根模块的选项一样，每个模块也包含state和mutations选项。模块的状态使用key关联到store的根状态。
						模块的mutation和getter只会接收module的局部状态作为第一个参数，而不是根状态，并且模块的action
						的context.state同样指向局部状态。
					》plugins 类型 Array<Function>
						一个数组，包含应用在store上的插件方法。这些插件直接接受store作为唯一参数，可以监听mutation(用于外部数据持久化、记录或调试)
						或提交mutation(用于内部数据如websocket或某些观察者)
					》strict 类型Boolean  默认值false
						使Vuex.store进入严格模式，在严格模式下，任何mutation处理函数以外修改Vuex state都会抛出错误。

				});
			》Vuex.Store实例属性
				》state 类型 Object  
					根状态 *只读*
				》getters 类型 Object
					暴露出注册的getter *只读*
			》Vuex.Store实例方法
				》commit(type:string,payload?:any) | commit(mutation:Object);//提交mutation
				》dispatch(type:string,payload?:any) | dispatch(action:Object);
					分发action。返回action方法的返回值，如果多个处理函数被触发，那么返回一个Promise。
				》replaceState(state:Object);
					替换store的根状态，仅用状态合并或time-travel调试
				》watch(getter:Function,cb:Function,options?:Object);
					响应式的检测一个getter方法的返回值，当值改变时调用回调函数。getter接受store的状态作为唯一参数。
					接受一个可选的对象参数表示Vue的vm.$watch方法的参数。
					要停止检测，直接调用返回的处理函数。
				》subscribe(handler:Function);
					注册监听store的mutation。handler会在每个mutation完成后调用，接受mutation和经过mutation*后*的状态作为参数。
					store.subscribe((mutation,state)=>{
						console.log(mutation.类型)
						console.log(mutation.payload)
					});
					//通常用于插件
				》registerModule(path: string | Array<string>, module: Module)
					注册一个动态模块
				》unregisterModule(path: string | Array<string>)
					卸载一个动态模块
				》hotUpdate(newOptions: Object)
					热替换新的 action 和 mutation。
			》组件绑定的辅助函数
				》mapState(map: Array<string> | Object): Object
				  创建组件的计算属性返回 Vuex store 中的状态。
				》mapGetters(map: Array<string> | Object): Object
				  创建组件的计算属性返回 getter 的返回值。
				》mapActions(map: Array<string> | Object): Object
				  创建组件方法分发 action。
				》mapMutations(map: Array<string> | Object): Object
				  创建组件方法提交 mutation。
23.单元测试
	》配置和工具
		任何兼容基于模块的构建系统都可以正常使用，但如果你需要一个具体的建议，可以使用Karma进行自动化测试。
		它有很多社区版的插件，包括对webpack和Browserify的支持。
	》简单的断言
		在测试的代码结构方面，你不必为了可测试在你的组件中做任何特殊的操作。只要导出原始设置即可：
		<template>
		  <span>{{ message }}</span>
		</template>
		<script>
		  export default {
		    data () {
		      return {
			message: 'hello!'
		      }
		    },
		    created () {
		      this.message = 'bye!'
		    }
		  }
		</script>
		//当测试组件时，所要做的就是导入对象和Vue然后使用许多常见的断言：
			//导入vue 和组件 进行测试
			import Vue from 'vue';
			import MyComponent from 'path/to/MyComponent.vue';
			//以下是Jasmine的测试 你也可以使用你喜欢的任何断言库或测试工具
			describe('MyComponent',()=>{
				//检查原始组件选项
				it('has a created hoo',()={
					expect(typeof MyComponent.created).toBe('function');
				});
				//评估原始组件选项中的函数的结果
				it('sets this correct default data',()=>{
					expect (typeof MyComponent.data).toBe('function');
					const defaultData=MyComponent.data();
					expect(defaultData.message).toBe('hello!');
				});
				//检查mount中的组件实例
				it('correctly sets this message when created',()=>{
					const vm=new Vue(MyComponent).$mount();
					expect(vm.message).toBe('bye!');
				})
				//创建一个实例并检查渲染输出
				it('renders the correct message', () => {
				    const Ctor = Vue.extend(MyComponent)
				    const vm = new Ctor().$mount()
				    expect(vm.$el.textContent).toBe('bye!')
				})
			});
	》编写可被测试的组件
		很多组件的渲染输出由它的props决定。事实上，如果一个组件的渲染输出完全取决与它的props，那么它会让测试变得简单，
		就好像断言不同的参数的纯函数的返回值。
		<template>
		  <p>{{ msg }}</p>
		</template>
		<script>
		  export default {
		    props: ['msg']
		  }
		</script>
		//你可以在不同的props中，通过propsData选项断言它的渲染输出
		import Vue from 'vue'
		import MyComponent from './MyComponent.vue'
		// 挂载元素并返回已渲染的文本的工具函数 
		function getRenderedText (Component, propsData) {
		  const Ctor = Vue.extend(Component)
		  const vm = new Ctor({ propsData }).$mount()
		  return vm.$el.textContent
		}
		describe('MyComponent', () => {
		  it('render correctly with different props', () => {
		    expect(getRenderedText(MyComponent, {
		      msg: 'Hello'
		    })).toBe('Hello')
		    expect(getRenderedText(MyComponent, {
		      msg: 'Bye'
		    })).toBe('Bye')
		  })
		})
	》断言异步更新
		由于Vue进行异步更新DOM的情况，一些依赖DOM更新结果的断言必须在Vue.nextTick回调中进行：
		// 在状态更新后检查生成的 HTML
		it('updates the rendered message when vm.message updates', done => {
		  const vm = new Vue(MyComponent).$mount()
		  vm.message = 'foo'
		  // 在状态改变后和断言 DOM 更新前等待一刻
		  Vue.nextTick(() => {
		    expect(vm.$el.textContent).toBe('foo')
		    done()
		  })
		})
24.服务端渲染
	》SSR完全指南
		在2.3发布后，我们发布了一份完整的构建Vue服务端渲染应用的指南。ssr.vuejs.org
/****************API********************/
1.全局配置
	Vue.config是一个对象，包含了Vue的全局配置。可以在启动应用之前修改下列属性：
	》silent 类型：boolean	 默认值：false
		 用法：Vue.config.silent=true;//取消Vue所有的日志与警告。
	》optionMergeStrategies 类型：{[key:string]:Function} 默认值:{}
		 用法:
			Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {//父实例 子实例 Vue实例
			  return child + 1
			}
			const Profile = Vue.extend({
			  _my_option: 1
			})
			// Profile.options._my_option = 2
			//自定义合并策略的选项
	》devtools 类型：boolean 默认值：true(生产版false)
		用法：Vue.config.devtools = true// 务必在加载 Vue 之后，立即同步设置以下内容
		配置是否允许vue-devtools检查代码。开发版本默认为true，生产版本默认为false。生产版本设为true可以启用检查。
	》errorHandler 类型 Function 默认值：默认抛出错误
		用法：Vue.config.errorHandler = function (err, vm) {
			  // handle error
		      }
		      //指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可以捕获错误信息和Vue实例。
	》ignoredElements 类型：Array<string> 默认值：[]
		用法：Vue.config.ignoredElements = [
			  'my-custom-web-component', 'another-web-component'
		      ]
		      //须使Vue忽略在Vue之外的自定义元素(如：使用Web Components API)，否则它会假设你忘记注册全局组件或拼错了
		      组件名称从而抛出一个关于 Unknown custom element 的警告。
	》keyCodes 类型{[key:string]:number | Array<number>} 默认值:{}
		用法：Vue.config.keyCodes={
				v:86,
				up:[38,87]
		      }
		      //给v-on自定义键位别名 即修饰符
		      @keyup.up='keyupHandler'
2.全局API
	》Vue.extend(options); 参数 { options }
		用法：使用基础Vue构造器，创建一个子类。参数是一个包含组件选项的对象。
		//data选项是特例，在Vue.extend()中它必须是函数
		<div id='mount-point'></div>
		//创建构造器
		var Profile=Vue.extend({
			template:'<p>{{firtName}}</p>',
			data(){
				return{
					firtName:'a'
				}
			}
		});
		//创建Profile实例并挂载到一个元素上
		new Profile().$mount('#mount-point');
	》Vue.nextTick([callback,context]);
		参数：
			{Function} [callback]
			{Object}   [context]
		用法：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM
			//修改数据
			vm.msg='hello';
			//DOM还没有更新
			Vue.nextTick(function(){
				//DOM更新
			});
	》Vue.set(object,key,value);
		参数：
			{Object} object
			{string} key
			{any}    value
		返回值：设置的值
		用法：设置对象的属性，如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。
		      这个方法主要用于避开Vue不能检测属性被添加的限制。
		      //注意：对象不能是Vue实例或Vue实例的根数据对象。
	》Vue.delete(object,key);
		参数：
			{object} object
			{string} key
		用法：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避免Vue
		      不能检测到属性被删除的限制，但是你应该很少会使用它。
			//注意：对象不能是Vue实例或Vue实例的根数据对象。
	》Vue.directive(id,[definition]);
		参数：
			{string} id
			{Function | Object} [definition]
		用法：注册或获取全局指令
			//注册
			Vue.directive('my-directive',{
				bind(){},
				inserted(){},
				update(){},
				componentUpdated(){},
				unbind(){}
			})
			//注册 --传入一个简单的指令函数
			Vue.directive('my-directive',function(){
				//这里将会被 bind 和 update调用
			});
			//getter 返回已注册的指令
			var myDirective=Vue.directive('my-directive');
	》Vue.filter(id,[definition]);
		参数：
			{string} id
			{Function} [definition]
		用法：注册或获取全局过滤器
			//注册
			Vue.filter('my-filter',function(value){
				//返回处理后的值
			});
			//getter 返回已注册的过滤器
			var myFilter=Vue.filter('my-filter');
			//使用 {{ value | filterName}}--通过filter处理value值
	》Vue.component(id,[definition]);
		参数：
			{string} id
			{Function | Object} [definition]
		用法：注册或获取全局组件，注册还会自动使用给定的id设置组件的名称
			//注册组件 传入一个扩展过的构造器
			Vue.component('my-component',Vue.extend({
				//options
			}));
			//注册组件 传入一个选项对象--**自动调用 Vue.extend**
			Vue.component('my-component',{
				//options
			});
			//获取注册的组件--始终返回构造器
			var MyComponent=Vue.component('my-component');
	》Vue.use(plugin)
		参数：
			{Object | Function} plugin
		用法：安装Vue.js插件。如果插件是一个对象，必须提供install方法。如果插件是一个函数，它会被作为install方法。
		      install方法将被作为Vue的参数调用。
		      //当install方法被同一个插件多次调用，插件将只会被安装一次。
	》Vue.mixin(mixin)
		参数：{Object} mixin
		用法：全局注册一个混合，影响注册之后所有创建的每个Vue实例。插件作者可以使用混合，向组件注入自定义的行为。
		      不推荐在应用代码中使用。
	》Vue.compile(template)
		参数：{string} template
		用法：在render函数中编译模版字符串。只在独立构建时有效
			var res = Vue.compile('<div><span>{{ msg }}</span></div>')
			new Vue({
			  data: {
			    msg: 'hello'
			  },
			  render: res.render,
			  staticRenderFns: res.staticRenderFns
			})
3.选项
	》数据
		》data	 类型：Object | Function  注意：组件的定义只接受function
			Vue实例的数据对象，Vue将会递归将data的属性转换为getter/setter,从而让data的属性能够响应数据的变化。
			**对象必须是纯粹的对象 包含零个或多个key value对**：浏览器API创建的原生对象，原型上的属性会被忽略。大概
			来说，data应该只能是数据--不推荐观察拥有状态行为的对象。
			一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。
			实例创建之后可以通过vm.$data访问原始数据对象。Vue实例也代理了data对象上所有的属性，因此访问vm.a等价于
			访问vm.$data.a。
			以_或$开头的属性不会被Vue实例代理，因为他们可能和Vue内置的属性，API方法冲突，你可以使用vm.$data._property的
			方式访问这些属性。
			当一个组件被定义，**data必须声明为返回的一个初始数据对象的函数**，因为组件可能被用来创建多个实例。如果data
			仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象。通过提供data函数，每次创建一个新实例后，我们能够
			调用data函数，从而返回初始数据的一个全新副本数据对象。
			如果需要，可以通过将vm.$data传入JSON.paren(JSON.stringify());得到深拷贝的原始数据对象。
			》实例
				var data={a:1}
				//直接创建一个实例
				var vm=new Vue({
					data:data
				});
				vm.a//1
				vm.$data === data//true
				//Vue.extend()中data必须是函数
				var Component=Vue.extend({
					data:function(){
						return {a:1}
					}
				});
				//注意：不应该对**data属性使用箭头函数**。因为箭头函数绑定了父级作用域的上下文
				//所以this将不会按着期望指向Vue实例
		》props 类型 Array<string> | Object
			props可以是数据或对象，用于接受来自父组件的数据，props可以是简单的数组或者使用对象作为替代，对象允许配置
			高级选项，如类型检测 自定义校验和设置默认值等
			Vue.component('props-demo',{
				//数组
				props:['size','myMessage'],
				//对象
				props: {
				    // 只检测类型
				    height: Number,
				    // 检测类型 + 其他验证
				    age: {
				      type: Number,
				      default: 0,
				      required: true,
				      validator: function (value) {
					return value >= 0
				      }
				    }
			});
		》propsData 类型 {[key:string]:any} 注意：只用于 new 创建的实例中
			//创建实例时传递props 主要作用是方便测试。
			//案例
			var Comp = Vue.extend({
				props:['msg'],
				template:'<div>{{msg}}</div>'
			});
			var vm=new Comp({
				propsData:{
					msg:'hello'
				}
			});
		》computed 类型 {[key:string]:Function | {get:Function,set:Function}}
			计算属性将被混入到Vue实例中。所有getter 和 setter的this上下文自动绑定为Vue实例。
			//注意，不应该使用箭头函数来定义计算属性函数。因为箭头函数绑定了父级作用域的上下文
			//所以this将不会按着期望指向Vue实例。
			//计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算
			var vm=new Vue({
				data:{a:1},
				computed:{
					//仅读取，值只须为函数
					aDouble:function(){
						return this.a *2
					}
					//读取和设置
					aPlus:{
						get:function(){
							return this.a +1;
						},
						set:function(v){
							this.a =v-1;
						}
					}
				}
			});
			vm.aPlus   // -> 2
			vm.aPlus = 3
			vm.a       // -> 2
			vm.aDouble // -> 4
		》methods 类型 {[key:string]:Function}
			methods将被混入到Vue实例中。可以直接通过VM实例访问这些方法，或者在指令表达式中使用。方法中的this
			自动绑定为Vue实例。
			//注意：不应该使用箭头函数来定义method函数。
			var vm=new Vue({
				data:{a:1},
				methods:{
					plus:function(){
						this.a ++;
					}
				}
			});
			vm.plus();
			vm.a//2
		》watch 类型 {[key:string]:string | Function | Object}
			一个对象，健是需要观察的表达式，值是对应回调的函数。值也可以是方法名或者包含选项的对象。
			Vue实例将会在实例化时调用$watch(),遍历watch对象的每一个属性。
			var vm=new Vue({
				data:{
					a:1,
					b:2,
					c:3
				},
				watch:{
					//函数
					a:function(newVal,oldVal){
					
					}
					//方法名
					b:'someMethod',
					//深度watcher
					c:{
						handler:function(newVal,oldVal){
							//
						},
						deep:true
					}
				}
			});
			//注意，不应该使用箭头函数来定义watcher函数
	》DOM
		》el 类型 string | HTMLElement 注意：只在由new 创建的实例中遵守
			提供一个在页面上已存在的DOM元素作为Vue实例的挂载目标，可以是Css选择器，也可以是一个HTMLElement实例。
			在实例挂载之后，元素可以用Vm.$el访问。
			注意：如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显示调用vm.$mount()手动开启编译。
			》提供的元素只能作为挂载点。不同于vue1.x所有的挂载元素会被Vue生成DOM替换，因此不推荐挂载root实例到<html>或<body>上。
			》如果render函数和template属性都不存在，挂载DOM元素的html会被提取出来用作模板，此时，必须使用Runtime+Compiler构建Vue库。
		》template  类型 string
			一个字符串模板作为Vue实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模版的内容有分发slot。
			如果值以#开始，则它用作选项符，将使用匹配元素的innerHTML作为模版，常用的技巧是用<script type='x-template'>包含模版。
			》处于安全考虑，你应该只使用你信任的Vue模版。避免使用其他人生成的内容作为你的模版。
			》如果Vue选项中包含render函数，template选项将被忽略
		》render 类型Function
			字符串模版的代替方案，允许你发挥js最大的编程能力。render函数接受一个createElement方法作为第一个参数
			用来创建VNode。
		
		
			
		
		 